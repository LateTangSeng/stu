.\" Autogenerated on Mon Aug 29 02:06:32 CEST 2016 by sh/mkman
.TH STU 1 "August 2016" "stu-2.2.5" "University of Koblenz-Landau"
.SH NAME
stu \- Build automation
.SH SYNOPSIS
.B stu 
[ -f
.I FILENAME
] [
.I OPTION 
]... [
.I TARGET
]...
.SH DESCRIPTION
Stu is a tool for build automation.  Like Make, it is used to call other
programs in 
order to build files.  Stu has two features that set it apart from Make:
(1) dynamic dependencies:  The dependencies of a target can be
themselves computed by a command.  When '[FILENAME]' (a filename
currounded by angle brackets) is used as a 
dependency, Stu will build the file FILENAME and read dependencies from
it.  (2) Parameters:  Names of files (and transient targets) can contain
parameters written using dollar syntax.  For example, a rule with a target
filename 'list.$name' will be used to build any file matching the
pattern 'list.*', and the parameter $name can be used in names of
dependencies and in the build command.  Targets may contain any number
of parameters. 

In general, Stu is very much like Make:  Instead of a 'Makefile', one uses
a file named 'main.stu', which is read by
Stu. Also like Make, Stu will build the first target it finds, except if
given an explicit target to built.   
Stu is designed to follow the conventions of Make,
of the shell, and of Unix and POSIX in general.  As an example,
the options -f and -k have the same meaning in Stu as they do in
Make. 

Rules for building files are read from the file 'main.stu', 
from a file passed by the -f option, or using the -F option. 

Names of targets to build passed on the command line follow a simplified Stu syntax,
in which the only special characters are the
transient target marker '@', and brackets '[]'.  All other characters
are interpreted as part of filenames.  When the -J option is used,
arguments passed on the command line are interpreted as filenames
without Stu syntax. 

.SH OPTIONS
.IP -a
Treat all trivial dependencies (declared with -t) as non-trivial.
.IP "-c FILENAME"
Pass a target filename, without Stu syntax.  This option only allows
file targets to be specified, not transient targets. 
.IP "-C EXPRESSION"
Pass a target using full Stu syntax.  The given expression is parsed as
if it was given as one or more dependencies in a Stu file.  As a result,
flags -p, -o and -t, brackets, parentheses and other Stu syntax elements
can be used, and spaces separate filenames.  
.IP "-E"
Explain error messages.  Only some error messages have explanations. 
.IP "-f FILENAME"
Read the given file instead of the default 'main.stu'.  If the name of a
directory is passed, the file 'main.stu' in the given directory is
read.  If '-' is passed, read standard input.  The -f option can be
used multiple times.  
.IP "-F RULES"
Pass rules in full Stu syntax.  
.IP -g
Treat all optional dependencies (declared with -o) as non-optional.
.IP -h
Output a short help and exit.
.IP "-j K"
Run K jobs in parallel.  K must be a positive integer.  The default
value is one, meaning that Stu does not start jobs in parallel. 
This option works like the corresponding option in GNU Make. The
parameter K is mandatory. 
.IP "-J"
Parse all arguments to Stu as filenames, disabling all Stu syntax that
is otherwise used.  Intended when Stu is used with tools such
as 'xargs'.  The -J option itself does not take an argument; it only
changes the way arguments outside of options are interpreted.
.IP -k
Keep going.  Do not stop running when an error occurs.  Instead, try to build as much
as possible.  This option is equivalent to that of Make. 
.IP "-K"
Don't delete partially built files when a command fails or when Stu is
interrupted.  By default, Stu will delete the target of a command after
the command fails or is interrupted, when the file is newer than it was
before starting the command. This option disables that behaviour.  Note
that with this option, a subsequent invocation of Stu may lead to the
partially built file being considered up to date. 
.IP "-m ORDER"
Specify the order in which jobs are run.  When ORDER is 'dfs' (the default),
Stu traverses the dependency graph in a depth-first fashion, in a way
similar to Make. When ORDER is 'random', the order in which jobs are run
is randomized within each target.  
.IP "-M STRING"
Run jobs in pseudorandom order, seeded by the given string. 
.IP "-n FILENAME"
Read targets from FILENAME, which must contain newline-separated
filenames.  No Stu syntax is processed. 
.IP "-o FILENAME"
Pass the given file as an optional dependency, i.e., build it only if it
already exists and is out of date. 
.IP "-p FILENAME"
Pass the given file as a persistent dependency, i.e., build the file but
ignore its timestamp. 
.IP "-P"
Print the set of rules to standard output and exit.  Note that Make 
has a -p option to print the rules, but does not exit.  The output
format is not specified. 
.IP "-q"
Question mode.  Do not execute any commands.  Instead, determine whether
the given targets are up to date.  The exit code is 0 when all given
targets (or the default target) are up to date, and 1 otherwise. 
.IP "-Q"
Quiet mode.  Suppress the messages on standard output that are not
related to building targets.  This includes 'Nothing to be done'
and 'Targets are not up to date' in conjunction with the -q option. 
.IP "-s"
Silent mode.  Suppress output of commands when they are executed. 
This option is comparable to the same option in Make.  Other output is
not suppressed, such as 'Nothing to be done'.  
.IP -v
Verbose mode.  Show internal information about the Stu algorithm on
standard error output.  All printed output lines begin with the
string 'VERBOSE  '.   
.IP -V 
Output the version number of Stu and exit.
.IP -w
Short mode.  Instead of outputting the commands, output the name of the
targets.  This is most useful when the commands themselves do not produce
any output. 
.IP "-x"
Call the shell using the -x option, i.e., each individual shell
statement is output to standard error output individually, instead of
outputting a full command at once on standard output.  In the output,
each command is prefixed by the value of '$PS4'. 
.IP -y
Disable color in output.  By default, Stu checks whether error output
and standard error output are TTYs and whether $TERM is defined and
not 'dumb' and if they are, uses ANSI escape sequences to color code
messages.   
.IP -Y
Enable color output unconditionally. 
.IP -z 
Output runtime statistics about child processes on standard output when
finished.  Does not include the runtime of the Stu process itself.
Includes the runtime of all child and grandchild processes, and so on.
Does not include the runtime of children or grandchildren that have not
been waited for (which only happens when Stu is interrupted by a
signal.) 

.SH OVERVIEW
A simple rule looks as follows:

    results.txt:  data.txt compute {
        ./compute <data.txt >results.txt 
    }

The colon may be omitted when there are no dependencies:

    A { echo la la la >A }

Here is an example of a rule containing three parameters.  Stu will use
pattern matching to match the target pattern to a given filename: 

    plot.$dataset.$method.$measure.eps:  
        data-$dataset.txt analyse-$method 
    {
        ./analyse-$method \\
            -m $measure \\
            -f data-$dataset.txt \\
            -o plot.$dataset.$method.$measure.eps
    }

Here is an example of a dynamic dependency.  The target 'compute' (a C
program) must be rebuild whenever its source code files are modified.
Since the set of source code files is large and may be changed by
changing the source code itself, we use the file 'compute.c.dep' to
contain the list of dependencies.  The file 'compute.c.dep' will then be
built by Stu like any file, and its content parsed for the actual
dependencies:  

    compute:  [compute.c.dep] {
        gcc -c compute.c -o compute 
    }
    $name.c.dep:  $name.c compute-dep {
        ./compute-dep-c "$name.c" >"$name.c.dep"
    }

Parameters can also use the syntax ${...}.

Syntax can be on multiple lines; whitespace is not significant.  No
backslashes are needed at line ends:

    output.txt: 
        a.data b.data c.data d.data e.data f.data g.data h.data i.data
        j.data k.data l.data m.data
    {
        do-stuff  >output.txt; 
    }

A rule may be entirely given on a single line: 

    system-info: { uname -a >system-info }

The following rule uses single quotes to declare filenames that include
parentheses and quotes:  

    '((':  'aaa\\"bbb' {
        ./bla -f 
    }

Multiple parametrized rules may match a target.  In that case Stu uses
the one that is the least parametrized, as defined by the subset
relation on the set of characters that are in parameters. 
When building 'X.txt' in this example, only the second rule is called:

    $name.txt: {  echo "$name" is the best >"$name.txt" }
    X.txt:  { echo X sucks >X.txt }

All commands are echoed by Stu.  Thus, you can output debugging
information (or any type of information) using shell comments.  There
is no need for the @echo construct of Make. 

    A:  {
        # This may take a while...
        compute-stuff >A
    }

Persistent dependencies:  In the following example, the
directory 'data' is a persistent dependency, i.e. 'data' is only
built when it does not exist, but it is never re-built.  A
persistent dependency is indicated by the -p flag.  This is
useful for directories, whose timestamps change when files are
created/removed in them.  

    data/file:  -p data {
        echo Hello >data/file
    }
    data: { mkdir data }

Optional dependencies can be declared with the -o flag.  An optional
dependency will never be built if it does not already exist.  If it
already exists, then its own rule is used (and its date checked) to
decide whether it should be rebuilt.  

    target:  -o input {
        if [ -r input ] ; then
            cp input target
        else
            echo Hello >target
        fi
    }

Trivial dependencies are denoted with the -t prefix.  They denote a
dependency that should never cause a target to be rebuilt, but if the
target is rebuilt for another reason, then they are treated like normal
dependencies.  Trivial dependencies are typically used for
configuration, i.e., for the setting up configuration of application.
Trivial dependencies are not allowed if the rule has no command. 

    target:  -t input;

Variable dependency:  the content of variables can come from files.  
In the following example, the C flags are stored in the file 'CFLAGS',
and used in the compilation command using the $[CFLAGS] dependency.  

    compute:  compute.c $[CFLAGS]
    {
        gcc $CFLAGS compute -o compute.c
    }
    CFLAGS: { echo -Wall -Werror >CFLAGS }

Variable dependencies may be declared as persistent as in $[-p X]
and as trivial as in $[-t X], but not as optional using -o. 
By default, the name of the variable set is the same as the filename.
Another variable name can be used in the following way:

    $[NAME = FILENAME]

Transient targets are marked with '@'.  They are used for targets such
as '@clean' that do an action without building a file, and for lists of
files that depend on other targets, but don't have a command associated
with them.  They are also used instead of variables that would otherwise
contain a list of filenames.  

Here is a transient target that cleans up the directory:

    @clean:  { rm -Rf *.o *~ }

Here a transient target is used as a shortcut to a longer name: 

    @build.$name:   dat/build.$name.txt; 

Here a transient target is used as a list of files.  Multiple targets
can depend on it, to effectively depend on the individual files:  

    @headers:  a.h b.h c.h;

    x:  x.c @headers {  
        cc x.c -o x
    }

    y:  y.c @headers {  
        cc y.c -o y
    }

.SH FEATURES
Like a makefile, a Stu file consists of rules.  In Stu, the order of
rules is not important, except for the fact that the first rule is
used by default if no rule is given explicitly.  Comments are written
with '#' like in Make or in the shell.  

The basic syntax is similar to that of make, but does not rely on
mandatory whitespace.  Instead of tabs, the commands are enclosed in
curly braces.  

Stu syntax supports two types of objects:  file targets and transient targets.  Files are
any file in the file system, and are always  
referenced by their filename.  Transient targets have names beginning with the '@'
symbol and do not correspond to files, but can have dependencies and
commands.  

A rule for a file in Stu has the following syntax:

    [>] TARGET [ : DEPENDENCY ... ] { COMMAND }

The target is a filename.  DEPENDENCY ... are depencies.
COMMAND is a command which is passed to the shell for building. 
Stu will always execute
the whole command block using a single call to the shell.  This is
different than Make, which calls each line individually.  This means
that you can for instance define a variable on one line and use it on
the next.  
Stu uses the -e option when calling the shell; this means that any
failing command will make the whole target fail.  

When the command of a file is replaced by a semicolon, this means that the file is
always built together with its dependencies:

    TARGET [ : DEPENDENCY ... ] ;

In this example, the file TARGET is assumed to be up to date whenever
all dependencies are up to date.  This can be used when two files are
built by a single command.  As a special case, writing the name of a
file followed by semicolon tells Stu that the file must always exist,
and is always up to date;  Stu will then report an error if the file
does not exist:

    TARGET ;

For a transient, the same syntax is used as for a file: 

    @TARGET [ : DEPENDENCY ... ] { COMMAND }
    @TARGET [ : DEPENDENCY ... ] ;

If a transient target includes a command, Stu will have no way of
remembering that the command was executed, and the command will be
executed again on the next invocation of Stu, even if the previous
invocation was successful.  Therefore, commands for transient targets will
typically output build progress information, or perform actions that do
not fit well the build system paradigm, such as removing or deploying
built files. 

Rules can have multiple targets, in which case the command must build
all the targets that are files.  If one of the targets is a transient
target, this effectively creates an alias for the file targets. 

    TARGET... [ : DEPENDENCY ... ] { COMMAND }
    TARGET... [ : DEPENDENCY ... ] ;

The operator '>' can be used in front of the target name to indicate
that the output of the command should be redirected into the target
file.  As an example, the following code creates the file 'HEADERS'
containing the output of the given 'echo' command:

    >HEADERS { echo *.h }

For a file target, content can be specified directly using the '='
operator:

    TARGET = { CONTENT ... }

The content is stripped of empty lines and common whitespace at the
beginning of lines, and written into the file. 

Using the equal sign with a file name creates a copy rule, i.e., the
given file is copied with the 'cp' command:

    TARGET = [ -p ] SOURCE;

By default, Stu will use '/bin/cp' to perform the copy.  This can be
changed by setting the variable $STU_CP.  If source ends in a slash
(outside of any parameter value), then Stu will look for a file with the
same basename as TARGET in the directory SOURCE.  The dependency SOURCE
can be declared a persistent dependency with -p.  Other flags are
not supported. 

A dependency can be one of the following:

    NAME    A file dependency

The target depends on the file with the name NAME.  Stu will make sure
that the file NAME is up to date before the target itself can be up to
date. 

    @NAME   A transient dependency

A transient target.  They represent a distinct namespace from files, and
thus their command do not create files. 

    -p NAME   A persistent dependency

Stu will only check whether the dependency exists, but not its
modification time.  This is mostly useful for directories, as the
modification time of directories is updated whenever files are added or
removed in the directory. 

    -o NAME   An optional dependency

Optional dependencies are never built if they don't exist.  If they
exist, they are treated like normal dependencies and their date is taken
into account for determining whether the target has to be rebuilt. 

A dependency cannot be declared as persistent and optional at the
same time, as that would imply that its command is never executed. 

    -t NAME   A trivial dependency

A trivial dependency will never cause the target to be rebuilt.
However, if the target is rebuilt for another reason, then the trivial
dependency will be rebuilt itself.  This is mostly useful for
configuration files that are generated automatically, including the case
of files containing the flags used to invoke compilers and other
programs. 

    '[' ['-n'] NAME ']'  A dynamic dependency

Stu will ensure the file named NAME exists, and then parse it as
containing further dependencies of the target.  The fact that NAME needs
to be rebuild does not imply that the target has to be rebuilt.  The
flag '-n' makes interpret the content of the file as a newline-separated
list of filenames.  Otherwise, the file is parsed in full Stu syntax. 

    '[' @NAME ']'  A dynamic transient target 

Brackets can also be used around a transient dependency name.  In that case, all
dependencies of the given transient targets will be considered dynamic
dependencies. 

    $[NAME] A variable dependency

The file NAME is ensured to be up to date, and the content of the file
NAME is used as the value of the variable $NAME when the target's
command is executed.  

    <NAME An input dependency

The dependency is a file which will be used as standard input for the
command.  

    ( ... )

Groups of dependencies can be enclosed on parentheses.  
Parentheses may not contain variable dependencies (i.e., something like
'$[NAME]'). 
The flags -p and -o can be applied to a group of dependencies given in
parentheses:

    -p ( ... )
    -o ( ... )

The flags -p and -o can be applied to dynamic dependencies:

    -p [ ... ]
    -o [ ... ]

in which case all resulting dynamic dependencies will be flagged as
optional or persistent. 

Both parentheses and brackets may be nested:

    ((A)) # Equivalent to A
    [[A]] # Read out dependencies from all files given in the file 'A'. 

.SH "PARAMETERS"

Any file or transient target may include parameters.  Parameters are
noted using the '$' character and are given a name.  Stu will match the
pattern to any file or transient target it needs to build.  Parameters can appear in
dependencies and in commands any number of times (included not appearing in them).  
In a target name, a parameter can only appear once.  The following
example contains the parameter $name:

    list.$name:    data.$name $name.in 
    {
        ./compute-list -n "$name"
    }

Parameters within a single target name must be separated by at least one
character, as otherwise Stu 
would not be able to determine how to split up a chain of characters
into two parameters.  Names of parameters cannot be empty.  

A file or transient target name may match more than one rule.  If that
is the case, then Stu will use the rule that dominates all other
matching rules. 
A rule A is defined to dominate another rule B if for
every character in the target filename there is inside a parameter in 
rule A, it is also inside a parameter in rule B, and at least one
character is in a parameter is rule B but not in rule B.  It is an error
when there is no single matching rule that dominates all other matching
rules. 

In the following example, the first rule dominates the other rules for
the file named 'a.b.c':  

    a.$x.c: ... { ... }
    a.$x:   ... { ... }
    $x.c:   ... { ... }

In the following example, no rule dominates the others for the
filename 'a.b.c', so Stu will report an error:  

    $x.b.c: ... { ... }
    a.$x.c: ... { ... }
    a.b.$x: ... { ... }

.SH "STATEMENTS"

Statements in Stu are introduced by '%' and serve a similar purpose to
the C preprocessor.  The token '%' must be followed by the statement
name. There may be any amount of whitespace (including none) between '%'
and the name of the statement. 

File inclusion is done using the '%include' statement. 
This can be put at any place in the input file, and will temporarily continue
tokenization in another file.  The filename does not have to be
quoted, except if it contains special characters, just like any other
filename in Stu.  If a directory is given after include (with or without
an ending slash), the file 'main.stu' within that directory is read. 

    % include a.stu
    % include "b.stu"
    % include 'c.stu'
    % include data/

To declare which version of Stu a script is written for, use
the '%version' statement:

    % version 2.3
    % version 2.3.4

Both variants will allow the script to be executed only with a version
of Stu of the correct major version number (2 in this example), and
whose minor version (and patch level) have at least the given values.
There may be multiple '%version' statements; each one is then checked
separately.  
In particular, it is possible to place a version statement in each
source file. 
This treatment of version numbers follows semantic versionning
(semver.org). 
The version statement will not prevent usage of Stu features that were
not present in the specified version. 

.SH "TOKENIZATION"

Unquoted filenames in Stu may contain the following ASCII characters:

    [a-z] [A-Z] [0-9] _ ^ ` + - . ~ / 

and all non-ASCII characters.  Filenames containing
other characters must be quoted by either single or double quotes.  The
characters -, + and ~ are not allowed as the first character of a name
if they are not quoted. 

The following characters have special meaning in Stu and cannot be used in
unquoted filenames:

    #     Comment (until the end of the line)
    %     Statement (followed by statement name and arguments)
    '     Quote; without escape sequences
    "     Quote; with escape sequences
    :     Separator for rule definition
    ;     For rules without body, end of variable declaration 
    -     Prefix character for flag, followed by a single character 
    $     Parameter
    @     Transient target marker
    >     Output redirection
    <     Input redirection
    =     Assignment rule, copy rule, named variable
    { }   Command
    ( )   List
    [ ]   Dynamic dependency

Comments introduced by '#' go until the end of the line.  Commands
starting with '{' go until the matching '}', taking into account shell
syntax, i.e., the command itself may contain more braces.  All other
characters are individual tokens and may or may not be separated from
other tokens by whitespace. 

Quoting in Stu is similar to quoting in the shell. 
Quoted or unquoted names which 
are not separated by whitespace are interpreted as a single name. 

Single quotes may contain any character except single
quotes and the NULL character '\\0'.
Backslashes and newline characters always have their literal meaning inside
single quotes. 

Inside double quotes, backslashes, double quotes and the dollar sign must be escaped by a
backslash.   Other C-like escape sequences are supported, too.  To be
precise, the following escape sequences are possible:  \\" \\\\ \\$ \\a \\b
\\f \\n \\r \\t \\v.  Dollars in double quotes introduce parameter names
in the same way as outside quotes. 
Double quotes may also contain unescaped newline characters. 
The NUL character '\\0' is not allowed inside double quotes. 

Spacing rules:   The lack of whitespace between tokens is an error
under certain conditions.  Specifically:  Whitespace must appear before opening
parentheses and brackets, and after closing parenthesis and brackets,
when the parenthesis or bracket in question would otherwise be
touching either a name token, or another parenthesis or bracket "from
outside".  I.e., the following combinations are now errors:

    )(  )[  ](  ][  )A  ]A  A(  A[

In these examples, 'A' stands for any name, including quoted names using
' and ".  All other tokens pairs can be written after each other without
whitespace, except when this would create a new token, which is only the
case for name tokens. 

The following characters are reserved for future extension: 

    * \\ | , 

.SH "SYNTAX"

The syntax of a Stu file is given in the following Yacc-like
notation.  This is the syntax after processing of statements, which are
introduced with '%'. 

    rule_list:        rule*
    rule:             ('@' NAME | ['>'] NAME)+ [':' expression_list] ('{' COMMAND '}' | ';') 
                      NAME '=' '{' CONTENT '}'
                      NAME '=' '-p'* NAME ';'
    expression_list:  expression*
    expression:       '(' expression_list ')' 
                      '[' expression_list ']' 
                      flag expression 
                      redirect_dep
                      variable_dep
    redirect_dep:     ['<'] bare_dep
    bare_dep:         ['@'] NAME
    variable_dep:     '$' '[' flag* ['<'] NAME ']'
    flag:             '-p' | '-o' | '-t' | '-n'

Stu files read via the -f option or as the default Stu file, as well as
the argument to the -F option must contain a 'rule_list'. 
A file included by brackets (a dynamic dependency) and arguments to the
-C option must contain an 'expression_list'.   

.SH "SEMANTICS"

Cycles in the dependency graph are not allowed. As an example, the
following results in an error:

    A:  B { ... }
    B:  A { ... }    

Cycles are considered at the rule level, i.e., cycles such as the
following are also flagged as an error, even though there is no cycle on
the filename level.  In the following example, it is not possible to
build the file 'a.gz.gz' from the file 'a', even though it would not
result in a cycle, but since both files 'a.gz' and 'a.gz.gz' use the
same parametrized rule, this is not allowed:

    $name.gz:  $name { gzip -k $name }

Cycles are possible in dynamic dependencies, where they are allowed
and ignored.  For instance, the following examples will correctly build
the file 'A', after having built 'B' and 'C':

    A:  [B] { echo CORRECT >A }
    B:  { echo [C] >B }
    C:  { echo [B] >C }

Symlinks are treated transparently by Stu.  In other words, Stu will
always consider the timestamp of the linked-to file.  A symlink to a
non-existing file will be treated as a non-existing file. 

.SH "EXIT STATUS"
.IP 0
Everything was built successfully or was up to date already.
.IP 1
Build error.   These indicate errors in the commands invoked and files
read by Stu.  Example:  a child process produced an error, or a
dependency was not found and no rule was given for it.  When using the
-q option, the exit code is 1 when the given targets are not up to
date. 
.IP 2
Logical error.  These indicate errors in the usage of Stu.  Examples are
syntax errors in Stu sources and cycles in the dependency graph. 
.IP 3
Both build and logical errors were encountered (when using the -k
option).  
.IP 4
An error occurred that made Stu abort execution immediately, regardless of
whether the -k option was used.  

.SH "ENVIRONMENT"

.IP STU_SHELL
If set, Stu calls the shell from the given location instead of '/bin/sh'.  The given shell
must support the -e and -c options.  This is mainly useful on systems
where '/bin/sh' is not a POSIX shell. 
.IP STU_CP
If set, Stu calls the 'cp' program from the given location instead
of '/bin/cp'.  The given version of 'cp' must support the syntax 'cp --
"$fileA" "$fileB"'. 
.IP STU_STATUS
Stu sets this variable to '1' in all child processes. In order to avoid
recursive invocation of Stu, Stu will fail on startup when the variable
is set. To circumvent this, unset the variable.  Recursive Stu is as
harmful as recursive Make.
.IP TERM
Used to determine whether to use color output.  This variable must be
set to a value different from 'dumb', and isatty(3) must return 1 for
color to be enabled.   

.SH "SIGNALS"

.IP SIGUSR1
When received, Stu will output a list of currently running jobs on
standard output, and
statistics about runtime, in a similar way to the -z option.  The
reported runtimes include only jobs that have already terminated, and
exclude currently running jobs. 
Multiple SIGUSR1 signals sent in succession may result in output only
printed once. 

.SH "COMPATIBILITY"

The Stu language is unique to this implementation, and the man page
serves as the reference for its syntax.  

Stu follows Semantic Versioning (semver.org).  The major version number
is increased when backward-incompatible changes are made.  The minor
version number is increased when features are added. The patch level is
increased for other changes. 

.SH "EXAMPLES"

This section contains more advanced examples of Stu usage.

The following declaration tells Stu that the file 'config.h' must exist,
and will allow Stu to give more meaningful error messages if the file is
not found.  

    config.h; 

Input and output redirection can be used to write commands that invoke
a filter such as sed, awk or tr.  The following example will build
the 'A' containing the string 'HELLO':

    >A: <B { tr a-z A-Z }
    >B { echo hello }

Variable dependencies may be included indirectly through transient targets
without commands, and through dynamic dependencies.  In the
following example, the variable $V will be passed through to the
commands for the targets A and B:

    V: { echo Hello >V }
    @x: $[V];         
    y: { echo '$[V]' >y }
    A: @x { echo $V >A }
    B: [y] { echo $V >B }

Trivial dependencies are often combined with variable dependencies to
implement flags, for instance to a compiler, as in the following
example. This will make sure that a change in the file 'VERSION' will not
lead to a recompilation of the program, but if 'program.c' is modified
and 'program' is rebuilt, then 'CFLAGS' will also be rebuilt. 

    VERSION; # Contains the version number; updated by hand
    >CFLAGS: $[VERSION] { echo -g -Wall -D VERSION=$VERSION }
    program:  program.c $[-t CFLAGS] { gcc $CFLAGS program.c -o program }

The -C option allows to pass any dependency in Stu syntax, and therefore
can be used in some advanced use cases:

    stu -C '-o X' # Re-build file 'X' only if it already exists
    stu -C '[X]' # Build all files given in file 'X'
    stu -C '%version 1.7' # Make sure Stu is compatible with the given version

The -F option allows to define rules on the command line:

    stu -F 'B:A {cp A B}' # Same as GNU's 'cp -u A B'
    stu -F 'A;' # Check that the file 'A' exists
    
.SH "BUGS"

The argument to the -j option (number of jobs to run in parallel) is
mandatory, as opposed to the behavior of GNU Make, where no argument
means to run as many jobs in parallel as possible. 

Files read as dynamic dependencies are parsed using the full Stu syntax,
meaning that certain characters must be quoted in them.  Future versions
of Stu may support newline-seperated file lists, as well as
NUL-separated file lists. 

Rule-level recursion is not allowed.  This excludes a recursive
parsing of C-like dependencies.  Rule-level recursion would be easy to
enable, but would open up problems related to infinite loops, which
would require Stu to have a maximal recursion depth.  

When the command fails and its target is a directory, Stu cannot remove
the directory as it does for regular files.  

Changing a command within a Stu file will not make the target to be
rebuilt.  This can be seen as both a feature or a bug. 
Also, all changes in a file will lead to rebuilds of other files, even if the
changes are trivial, e.g., when only whitespace was changed in C source
code.  Furthermore, touching a file without changing the contents will also
lead to a rebuild, although it is not needed.  Both limitations could be
removed by using fingerprints instead of modification times. 

All timestamps have only one-second resolution, except when the
Linux-only USE_MTIM option is set on compilation.  (Which it is by
default on Linux.)  

Filenames in Stu are literal.  Stu does not recognize it when two
different names refer to the same file. 

Using optional dependencies may make a second invocation of Stu not
output 'Nothing to be done', as the optional dependency may have been
created by subsequent targets. 

.SH AUTHOR
Jérôme Kunegis <kunegis@uni-koblenz.de>
.SH "SEE ALSO"
.BR make (1)

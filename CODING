Here are the relevant coding conventions we use. 

== Standards == 

* Following the POSIX standard
* Follow the GNU Coding Standards, except for coding style, but don't
  use GNU extensions  
* Use the C++11 version of C++; avoid GCC extensions
* Compilation is done in a single step by compiling the file 'stu.cc'.
  All other source files are actually *.hh files which are included.
  Therefore, we don't have to care about separation of declarations and
  definitions.  If one day we think the compilation has become too slow,
  we'll start using .o files. 
* Names of targets in the Makefile follow the GNU Coding Standards  
* Follow the behavior of Make as much as reasonable (e.g. the -k and -j
  options behave just as in Make), but not where Make loses
* It is safe to assume a POSIX environment; there is no need to cater
  for "special" operating systems that lack core POSIX features.  E.g.,
  we always assume the directory separator is '/'.  
* Use SemVer.org for version number semantics.  We consider only changes
  on the Stu file specification, not in things like the output of Stu of
  the supported options. 

== Style == 

This is my preferred style.  --Jerome Kunegis

* All the following rules are broken when necessary :)
* K&R brace style
* Single tabs for indentation (set your editor to show them at the width
  you prefer)  
* Use C-style comments (/* ... */) for normal comments
* Use C++-style comments on column zero (// ...) for quickly commenting
  out code and for writing TODO items; this allows us to search all
  source files for the string '//' to find areas that are currently
  worked on.  Code pushed to git does not contain '//'.  When used, we
  put '//' at the beginning of the line, not preceded by whitespace.  
* In comments, names of variables are in all uppercase. 
* Use 72-character lines in general, but allow more where reasonable,
  e.g., to avoid breaking message string literals
  (note:  tabs may be interpreted as different widths making this an
  approximate rule; authors use 8-char tabs)   
* Use 'nullptr' as the null pointer constant, instead of 'NULL', as per
  C++11 
* No space before the assignment operator 
* We enable many G++ warnings in debug mode 
* For vectors and strings, use operator[] for access, keeping in mind
  that this function has undefined behaviour when the argument is out of
  range.  In debug mode with glibc++, these functions include range
  checking, and therefore bugs relating to their usage may be caught in
  unit testing in that way. 
* For maps, we mostly use .at() for access, which terminates
  when the value is not contained, to avoid inserting values
  accidentally with operator[]. 

== Dynamic variables ==

(1) Variables derived from the following classes are managed dynamically
using shared_ptr/unique_ptr: 

* all parametrized names and targets (in target.hh)
* Rule
* Token
* Dependency

I.e., we always assume an object of one of these types may be of a
subtype.  

(2) Objects of type Execution are allocated using new() and never
released; this is necessary for caching.  They are always accessed
through ordinary pointers. 

(3) Other types can be used as pass-by-value, or pass-by-reference if
necessary. 

== Common variable names ==

* 'text':  a string used for display
* 'format[_*]':  a function that formats an object for display
* 'filename':  a filename
* 'error':  an error code or exit code (they are the same in Stu)

These are the relevant coding conventions we use. 

== Standards == 

* Follow the POSIX standard.  It is safe to assume a POSIX environment;
  there is no need to cater for "special" operating systems that lack
  core POSIX features.  E.g., we always assume the directory separator
  is '/'.   
* Follow the GNU Coding Standards, except for coding style, but don't
  use GNU extensions.  For coding style, see below. 
* Use the C++11 version of C++; don't use GCC extensions.  Or any other
  extensions for that matter.  Source files are named '*.hh' and '*.cc'.  
* Compilation is done in a single step by compiling the file 'stu.cc'.
  All other source files are actually '*.hh' files which are included.
  Therefore, we don't strictly separate declarations and definitions.
  If one day we think the compilation has become too slow, we'll start
  using '*.o' files though.  
* Names of targets in the Makefile follow the GNU Coding Standards. 
* Use SemVer.org for version number semantics.  We consider only changes
  on the Stu file specification and options marked as stable in
  'OPTIONS'.  See the file 'NEWS' for details.   

== Style == 

This is my preferred style.  --Jérôme Kunegis

* All the following rules are broken when necessary. 
* K&R brace style.
* Tabs for indentation at the beginning of lines.  Set your editor
  to show them at the width you prefer.  I use the default 8-char tabs. 
* Spaces for indentation in the middle of lines.
* Use C-style comments (/* ... */) for regular comments
* Use C++-style comments on column zero (// ...) for quickly commenting
  out code and for writing TODO items; this allows us to search all
  source files for the string '//' to find areas that are currently
  worked on.  Code pushed to git does not contain '//'.  When used, we
  put '//' at the beginning of the line, not preceded by whitespace.  
* In comments, names of variables are in all uppercase. 
* Use 72-character lines in general, but allow more where reasonable,
  e.g., to avoid breaking message string literals.  Since tabs may be
  interpreted as different widths, this is an approximate rule; authors
  use 8-char tabs. 
* Use 'nullptr' as the null pointer constant instead of 'NULL', as per
  C++11.  In comments, call it "null" (in lowercase, like you would
  write 'zero' or 'five'). 
* No space before the assignment operator and around parentheses.
  Otherwise, spaces around most operators. 
* We enable many G++ warnings in debug mode, and write the code so as to
  suppress them if necessary.  (Stu is developed using G++.)
* For vectors and strings, use operator[] for access, keeping in mind
  that this function has undefined behavior when the argument is out of
  range.  In debug mode with glibc++, these functions include range
  checking, and therefore bugs relating to their usage may be caught in
  unit testing in that way. 
* For maps, we mostly use .at() for access, which terminates
  when the value is not contained, to avoid inserting values
  accidentally, which is what operator[] does. 

== Dynamic variables ==

(1) Variables derived from the following classes are managed dynamically
using shared_ptr/unique_ptr: 

* all parametrized names and targets (in target.hh)
* Rule (even though it is not polymorphic) 
* Token
* Dependency

I.e., we always assume an object of one of these types may be of a
subtype.  

(2) Objects of type Execution are allocated using new() and never
released; this is necessary for caching.  They are always accessed
through ordinary pointers. 

(3) Other types can be used as pass-by-value, or pass-by-reference if
necessary. 

== Variable names ==

Variables names uses underscore for word separation.  No camel case.   

The following names are used systematically: 
* 'text':  a string used for display
* 'format[_*]':  a function that formats an object for display
* 'filename':  a filename
* 'error':  an integer error code or exit status (they are the same in Stu)

Many variable names are written in "big endian" in defiance of English
noun phrase syntax.  In such names, the first part indicates the type
(to a higher precision then the C++ type), and the second part indicates
the meaning of the variable.  For instance, a variable denoting a
filename used previously may be named 'filename_old' instead of the
expected 'old_filename'.  

== Shell scripts ==

When writing shell scripts, make sure to follow POSIX.  Writing portable
and safe shell scripts is hard, and the authors follow many other rules
than those given here, mostly based on experience.  There are many more
things to be said about portable shell scripting.  

* Only use POSIX features of the shell and of standard tools.  Read the
  manpage of a tool on the POSIX website
  (http://pubs.opengroup.org/onlinepubs/9699919799/), rather than your
  locally installed manpage, which is likely to describe extensions to
  the tool.  
* Use '##' for quickly commenting out lines, analogously to '//' in C++
  code.  Code pushed to Github does not contain such lines. 
* Sed has *only* basic regular expressions.  In particular, no '|', '+',
  and no escape sequences like '\s'/'\S'/'\b'/'\w'.  The -r and -E
  options are not POSIX; they are GNU and/or BSD extensions.
  A space can be written as [[:space:]].  '+' can be emulated with
  \{1,\}.  There is no way to write alternatives, i.e., the
  '|' operator in extended regular regular expressions.  (Note:  there
  are rumors that -E is going to be in a future POSIX standard; we'll
  switch to -E once it's standardized.)
* Grep however has the -E option for extended regular expressions.  Grep
  is always be invoked with the -E *or* the -F option.  (Using basic
  regular expressions with Grep is also portable, but we don't do it.)
* Shell scripts don't have a filename suffix.  Use '#! /bin/sh' and set
  the executable bit.  The space after '!' is not necessary, but has a
  certain tradition and we think it looks good, so we always use it. 
* 'test' does not support the -a option.  Use && in the shell instead.
  POSIX has deprecated 'test -a'.
* The 'recursive' option to programs such as 'ls' and 'cp' is -R and not
  -r.   '-r' for recursive behavior is available and prescribed by POSIX
  for *some* commands such as 'rm', but it's easier to always use '-R'.
  Mnemonic:  Output will be *big*, hence a big letter.  The idiomatic
  'rm -rf' is thus not recommended, and 'rm -Rf' is used instead. 
* Use $(...) instead of `...`.  It avoids many quoting pitfalls.  In
  shell syntax, backticks is a form a quote which also executes its
  content.  Thus, characters such as other backticks and backslashes
  inside it must be quoted by a backslash, leading to ugly code.  $(...)
  does not have this problem.  Also, in Unicode ` is a standalone grave
  accent character, and thus a letter-like character.  This is also the
  reason why ` doesn't need to be quoted in Stu, like any other letter.
  The same goes for ^ and the non-ASCII ´. 
* Double-quote all variables, except if they should expand to multiple
  words in a command line.  Also, use -- when passing variables as
  non-option arguments to programs.  E.g. write 'cp -- "$filename_from"
  "$filename_to"'.  All other invocation styles are unsafe under *some*
  values of the variables.  Some programs such as printf don't have
  options and thus don't support '--'. 
* Always use 'IFS= read -r' instead of 'read'.  It's the safe way to
  read anything that's \n-delimited.
* With 'echo', both '-n' and \c are non-portable.  Instead, use printf.
  In general, printf is an underused command.  It can often be used
  judiciously instead of 'echo'.  Note that the format string of printf
  should not start with a dash.  In such cases, use %s and a subsequent
  string, that can start with a dash.

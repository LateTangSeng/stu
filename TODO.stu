#==== Small features that complete what we already have (for version 1) ====

#
# Option to pass rules in full Stu syntax (-F)
#

#
# Hard-coded content
#

# Will the file begin and end with spaces?
CFLAGS = { -g -Werror }

# Will the file begin with a newline?   No.
LIST = {
aaa
bbb
ccc
}

# Will indentation be preserved?   No.
LIST2 = {
   aaa
   bbb
   ccc
}

# Empty file
A = {}

#
# Copy rule
#

a.bib = ../bib/references.bib;

# Allow the same-name shortcut (ending in slash or not [with fopenat]):
konect.bib=  ../../projects/konect/;
konect.bib=  ../../projects/konect;

#
# Assign a name to a dynamic variable.  Useful when the name of the file
# contains characters that are not allowed in shell variable names. 
#

prog:  prog.c
	$[CFLAGS = config/CFLAGS]
{ 
	gcc $CFLAGS -c prog.c -o prog
}

#
# Option -W FILENAME:   What-if mode.  Pretend that file FILENAME has
# just been modified. 
#

#
# Have a way for dynamic dependencies to contain \0-separated filenames,
# to avoid quoting. 
#

A: [B],0 { xargs -0 B ... }

>B:  {
	find ... -print0
}

# Alternatively, detect such files automatically. (e.g., any file
# containing the zero character is such a file, or using specific endings.)

#
# Phonies in dynamics
#

# A will depend on the content of B, C and D. 
A:  [@x];
@x: B C D;

# Needs each phony to store the list of files it depended on, and is
# thus non-trivial to implement.  Or, alternatively, needs to implement
# a 'phony-hierarchy' like we have for files at the moment. 

#
# Advanced file inclusion 
#

# Include rules for C++ compilation; may search within predefined paths
# ($STUPATH) 
% include c++.stu
% include static/
 
# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory. 
%import src/main.stu
%import src/

#
# Option -B:  Remake all targets regardless of dates
#

#
# Option -N:  dry run, but build dynamic dependencies 
#

# 
# An option (-u) to consider all targets up to date.  I.e., execute only the
# minimum to get the given files built. 
#

#
# Multiple targets declare a command that is able to build multiple
# files at once.
#

# Basic case:  two files are created 
$NAME.eps $NAME.runtime:  calculate {
	./calculate $NAME -o $NAME.eps --runtime=$NAME.runtime
}

# Can also be used to define phony shortcuts 
@bidd.$NETWORK plot/bidd.a.$NETWORK.eps: { ... }

# * They must all contain the same set of parameters. 
# * Only one can have an output redirection. 
# * If the desired target exists but not other targets, does that make
#   the rule be executed?  

# This will also allow to define multiple files as present:
A B C;

# This will allow a lone semicolon as a no-op:
;

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [B];
A: [B],i; 

#
# New flag to ALWAYS build a target.  (We may already have this)
#

#==== Backward-incompatible features (in the switch to version 2) ====

#
# Make 'single quotes' and "double quotes" behave like in the shell,
# i.e., with respect to what needs to be quoted inside them. 
#

'abc"def';
"network $NAME";
"aaa'bbb";

#
# Don't allow filenames that start with '+' or '-', but allow these in
# the middle of filenames.  

#
# Keep track of spacing between tokens, and disallow no space in
# situations that will later be used for string concatenation. 
#

#
# What happens with relative and absolute pathnames?  When two names
# refer to the same file?  Do we need to 'normalize' names?
#

# This will fail because ../../bib/[NAME].bib will match [NAME].bib.
# Instead, be able to write ./[NAME].bib
A:   a.bib b.bib c.bib;
$NAME.bib:  ../../bib/$NAME.bib { cp ... }
a.bib;

# Rules:
#     [NAME].bib:    a .bib file anywhere
#     ./[NAME].bib:  a .bib file in the current directory

# Remove trailing slash from directory names.
A:  ?tmp/ {...}
tmp: {...}

#==== Features of Stu 2 ====

#
# String multiplication.  String multiplication is to work both with the
# binary operator '*' as well with juxtaposition.  Juxtaposition is
# backward incompatible, as in Version 1 strings like "A[B]" where
# interpreted as two dependencies, and with it they will be interpreted
# as one. 
#

A:  B * C;    	        # Binary multiplication operator
A:  B * (C D); 	        # Parentheses
A:  B[C];      	        # Justaposition
A:  [B]C;      	        # OK
A:  B(C D);    	        # OK
A:  B(C D)E;   	        # OK
A:  B[C]D;     	        # OK
A:  [B] * [C]; 	        # OK
A:  (A B) * (C D); 	# OK
A:  [B][C];             # OK
A:  (A B)(C D);         # OK
A:  (!B) * (C);    	# OK
A:  (?B) * (C);    	# OK
A:  (B) * (!C);    	# error
A:  (B) * (?C);    	# error
A:  (?B) * (!C);   	# error
A:  (<B) * (C);    	# OK
A:  (B) * (<C);    	# error
A:  !B(C D);       	# OK
A:  ?B(C D);       	# OK
A:  <B(C);         	# OK
A:  <B(C D);       	# error
A:  @B(C);         	# OK
A:  @B(C D);     	# OK
A:  B * @C;      	# error 
A:  $[B] * C;    	# error
A:  B * $[C];    	# error
A:  <B * C;      	# OK (or maybe:  ambiguous)
A:  B * <C;      	# error
A:  <B[C];		# OK iff C contains exactly one dependency (or an error)
@A: @B[C];       	# OK
A:  B@C;		# error
A.$X.$Y:  $X * $Y       # OK (can be contiguous)
A.$X.$Y:  $X.a * b.$X   # OK (despite duplicate parameter) 
A.$X.$Y:  $X. * $Y      # OK
A.$X.$Y:  $X * .$Y      # OK

# More examples

@headers:  (config parse build).h

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

#
# Use '-' and '+' as additional flag characters.  Could even be used for
# option-like flags. 
#

A:  
	-r B
	+x C
	--trivial D
	--optional ( E F ) 
	--existence-only [ --optional G ]
{ ... }

#
# Assignment features
#

# Multiple names result in catenation
A = B C D;

# Combine with phony target
A = @x;
@x:  B C D;

# Combine with dynamic target
A = [X];
<X { echo B C D }

#
# Chain of commands are useful for dynamic dependencies
#

@bidd:  [>dep.bidd]:  <NETWORKS { sed -e 's,^,bidd.,' }

#
# Input redirection for a dynamic dependency or list is catenation
#

>all.gz:  <[files] { gz }

# Not very useful since it can be emulated very simply using cat:
>all.gz:  [<files] { xargs cat | gz }

>A: <(B C) { sed -e '...' }

# With phonies
>A: <@x { sed -e '...' }
@x:  D E F;

# With dynamic dependencies
>A:  <[deps] { sed -e '...' }
>deps { ... }

#
# Line number syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

%line ...

#
# An option for automatic logging:  write all output (stdout/stderr) of
# commands to a file (a different file per target).  Use the -l option. 
#

#
# -m bfs (breadth-first order) and -m target (pseudotarget by target
# name) 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '?':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
? $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# Variables of the flags that apply to all children, not just immediate
# ones.  
#

$ stu '!!A'

# will completely ignore timestamps in all files.  

# This will also make
# cover cases that are implemented as options at the moment, e.g. -g:

$ stu '\?A'

# is equivalent to

$ stu -g A

# In this example, '\' is the negation operator. 

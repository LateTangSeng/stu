#
# Concatenation [2.5]    test/2.5-*
#

A:  B(C);    	        
A:  B(C D); 	        # Parentheses
A:  B[C];      	        # Juxtaposition
A:  [B]C;      	        # OK
A:  B(C D);    	        # OK
A:  B(C D)E;   	        # OK
A:  B[C]D;     	        # OK
A:  [B][C]; 	        # OK
A:  (A B)(C D); 	# OK
A:  [B][C];             # OK
A:  (-p B)(C);    	# OK
A:  (-o B)(C);    	# OK
A:  (B)(-p C);    	# error
A:  (B)(-o C);    	# error
A:  (-o B)(-p C);   	# error
A:  (<B)(C);    	# OK
A:  (B)(<C);    	# error
A:  -p B(C D);       	# OK
A:  -o B(C D);       	# OK
A:  <B(C);         	# OK
A:  <B(C D);       	# error
A:  @B(C);         	# OK
A:  @B(C D);     	# OK
A:  (B)(@C);      	# error 
A:  ($[B])(C);    	# error
A:  (B)($[C]);    	# error
A:  <B(C);      	# OK 
A:  (B)(<C);      	# error
A:  (B)<C;              # OK, two distinct dependencies 'B' and 'C' (with input redirection)
A:  <B[C];		# OK iff C contains exactly one dependency (otherwise an error)
@A: @B[C];       	# OK
A:  B@C;		# error, or not concatenation 
A.$X.$Y:  ($X)($Y)      # OK (can be contiguous)
A.$X.$Y:  ($X.a)(b.$X)  # OK (despite duplicate parameter) 
A.$X.$Y:  ($X.)($Y)     # OK
A.$X.$Y:  ($X)(.$Y)     # OK

@headers:  (config parse build).h

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

# Copy all *.dat files to the backup/ directory, but only if they don't
# exist yet, or if they have changed. 
@all: backup/[FILES];
>FILES: { echo *.dat ; }
dest/$file = $file;

# The following has ambiguous syntax.  Define and document it to have
# higher precedence for concatenation, then the flag.  (Should be the
# default in the current implementation.)  
A:   -p ( X )( Y );

# Other tests
A:  B() { cp B A }  B = {correct}
A:  ()B { cp B A }  B = {correct}
... (a)(b)(c) 
... A<B  # Two dependencies
... A(<B)  # Error
... (A (B C))D  # same as:  AD BD CD
... ("'")X  # escape the quote correctly in error message 
... ()(A)  # Empty or just 'A' (empty would be logical, because () is an
           # empty list
A:  list.[B];
A:  list.[[B]];
A:  [[B]][[B]]; 
A:  [[B][C]]; 
A:  [[(B)(C)]]; 
A:  ()();  # Empty or error?   Empty is logical; error may catch some Stu code bugs. 

# Test a case in which the concatenated files are not readable, i.e. because of chmod(2). 

# Ordering:  in 
A:  (X Y)(W Z);
# the dependencies are made in order XW XZ YW YZ. 

A: [[X]](Y);  

A:  A(-o B);  # Error 
A:  A[-o B];  # When B does not exist:  empty dependency list. 

A:  @B(C);    # OK
A:  B(@C);    # Error
A:  @B(@C);   # Error

A:  $[B(C D)];  # ??

A:  B.${X}(${Y});  # Error because of contiguous parameters 

A:  -o(B)(C);   # Make sure -o is not ignored 

A:  -o @B(C);  @BC:  xxx;   # Make sure 'xxx' is correctly handled as an optional target 

A:  (A)(B);   # Error:  No rule for target 'AB'
A:  @(A)(B);  

# Two different meanings [assuming three strings in each of X/Y/Z):
A:  list.[X Y Z];   # Same as list.( [X] [Y] [Z] ):  9 variants
A:  list.[X][Y][Z]; # Multiple all together:  27 variants 

A:  ((X)(Y))(Z);
A:  (X)((Y)(Z)); 

A:  X(Y);   # OK
A:  [X][Y]; # OK
A:  [X]@Y;  # Error
A:  (X)Y;   # OK
A:  X[Y];   # OK
A:  [X]Y;   # OK
A:  (X)(Y); # OK
A:  (X)[Y]; # OK
A:  [X](Y); # OK

# The following two are not the same 
A:  [X][[Y][Z]];
A:  [[X][Y]][Z];

A:  list.(1 2)(1 2)(1 2)(1 2)(1 2)(1 2)(1 2)(1 2)(1 2)(1 2)(1 2); 

A:  [ (X) (Y) (Z) ]; 
A:  list.((((((((((X)))))))))); 
A:  list.((((((((([X]))))))))); 
A:  list.(((([(((((X)))))]))));
A:  list.[(((((((((X)))))))))]; 
A:  list.([X][Y]); 
A:  (X)((Y)(Z));
A:  ((X)(Y))(Z); 

A:  [B];   B = { ([X])(([Y]([Z]))) }   X = { list. }   Y = { 1 2 }   Z = Y;

A:  list.[X][X][X][X][X][X][X][X];   X = { 1 2 }   >list.$n { echo Number "$n" ; }

A: [(X)(Y)(Z)]; 

A: list.[X];   X = {[Y]}   Y = {Z};  # Equivalent to   A: list.Z;
A: [list.[X]]; X = {[Y]} Y = {Z} list.Z = {Q}  # Equivalent to    A: Q;

# This case.  Make sure all six list.* files are built. 
@all:  A B;
A:  list.a[[M]];
B:  list.b[[M]];
M = { N }
N = { 1 2 3 }
list.$x = { xxx }

# Order of parts
A:  [B][C] { ... }
>B { sleep 2 ; echo list. ; }
C = { 1 2 3 }
list.$n;

# Start building 'list.C' immediately, and 'list.D' later. 
A:  list.([B] C) { ... ; }
B = { sleep 1 ; echo D ; }
>list.$n { echo "$n" ; }

# Should this mean 'list.', or an empty list as dependencies of 'A'?  It
# should mean an empty list. 
A:   list.[B] { ... }
B = { }

# Works, and 'B' is stat()'ed only once. 
A:  -o B { touch A ; }
B { exit 1 ; }

# Should we allow this?  Yes.  Since 'C' is empty, this is an empty
# dependency. 
A: @[C]
{
	touch A
}
C { touch C ; }

# Strong cycle in the context of concatenation 
A:  list.[B];
B = {C}
list.C:  A; 

A:  [B] { cat E >A ; }
B = { list.[C] }
C = { D }
list.D = {E}
E = {correct}

# This fails because there is no rule for 'D', but with the -k option,
# 'E' is still built. 
A: [[B]] { touch A ; }
B = { C D }
C = { E }
E = { echo eee >E ; }

>A:  B -t list.[C] { cat B list.{1,2,3} ; }
B = {bbb}
C = {1 2 3}
>list.$n { echo "$n$n$n" ; }

# Execute with -j2 
A:  C X [[B]] { cat C X D >A ; }
B {           echo C   >B ; }
C { sleep 2 ; echo D   >C ; }
X { sleep 1 ; echo xxx >X ; }

# Execute with -j2 
A:  [C] X [[B]] { cat C X D >A ; }
B {           echo C   >B ; }
C { sleep 2 ; echo D   >C ; }
X { sleep 1 ; echo xxx >X ; }

# Transients don't pass dependencies for dynamics when they are in a
# rule with multiple targets.
# This example succeeds; 'D' is not built. 
A: [@x] { cat B C >A ; }
@x B: C { cp C B ; }
C = {D}
D { exit 1 ; }

A: @[X] { cp C A ; }
X = { y }
@y: C;
C = {correct}

# * Update the man page
# * Concatenation in debug mode 

# Dynamic transients.  This does the expected thing, and will be
# easy to implement after the big "concatenation" cleanup.  Does not
# work if the transient in question has a command, or is co-target with
# a file.  Test these two cases. 

#
# * Don`t use `;` in sed
# * Don`t use \s, \S and \t in sed
#

#
# Make sure that in -j2 -k mode, the "successfully built" message is
# output just once, when the rule that was run has multiple targets.
#

#
# TODO document the -0 in the manpage.
#

#
# In the following case, there should be an explanation message that two
# parameters cannot be continguous.
#

A.$X$Y;

#
# When an unknown flag is encountered, have an explanation of all valid
# flags.  
#

#
# When '*' is encountered in a file, show an explanation saying which
# characters are not allowed. 
#

#
# At the moment, "stu -g" does not disable the flag -o in copy rules, i.e.
#
#   A = -o B;
#
# but it should.  
#

#
# sh/test:  log all tests and their runtime, version number, date, etc.
# This is to detected regression such as "a new version of Stu is much
# slower than old versions."
#

# 'A' will contain the three lines 'x', 'y' and 'z'
>A: [@x] { cat X Y Z ; }
@x:  X Y Z; 
X = {x}   Y = {y}  Z = {z}

#
# Check that random mode and -j2 work together when there is just a
# single thing to run in parallel.  Same for higher -jK when there are
# less than K things to run. 
#

#
# Write a test with really long filenames and really long chains of
# dependencies.  
#

#
# Test what happens when a file passed with -n contains a \0 character.
# It should be considered a syntax error and thus should should be a
# logica error (exit status 2). 
#

#
# Have a feature to indicate that a file contains only a single
# filename.  To complement -n and -0.  Must produce a logical error when
# the file contains the nul byte '\0'. 
#

#
# Make sure we don't compile in any of the multi-threaded libraries. 
#

#################### Further features #########################

#
# Allow a better integrated syntax on the command line after '--'.  This
# will complement the options -o/-p/-n/-0.
#
# Write a tokenizer for it and use the usual parser.  The tokenizer
# should:
#    - recognize operators only at the beginning and end of arguments
#    - treat whitespace within arguments as part of the name, and only
#      consider the separation between arguments to be whitespace
#    - don't support '$'
#    - don't need space after flags 
#

$ stu -- [ -n FILES ]
$ stu -- -o FILE
$ stu -- -oFILE
$ stu -- [FILE]
$ stu -- [-oFILE]

#
# The 'trivial' flag '-t' should "go up" when applied to the
# dependencies of transient targets. 
#

# 'V' is built because 'A' does not exist. 
A: @x {
	[ -r V ] || {
		exit 1
	}

	cat V >A
}
@x:  -t V; 
V = {correct}

# 'V' is built 'A' does not exist.  The '-t' has to "go up". 
A: @x {
	[ "x$V" = xcorrect ] || {
		exit 1
	}

	echo "$V" >A
}
@x:  $[-t V];
V = {correct}

# The '-t' has to "go up".  Use this in KONECT. 
@all:   list.out;
>list.$name:
	@octave
{
	./list.octave Hello 
}
@octave:  -t ( list.octave $[P] );
list.octave 
{
	cat >list.octave <<EOF
#! /bin/sh
[ "x$P" = x... ] || {
	exit 1
}
echo "$@"
echo correct >A
EOF
	chmod u+x list.octave
}
P = {...}

# Even when a transient target has a command, the '-t' "goes up". 
A: @x {
	[ -r V ] && {
		exit 1
	}

	echo correct >A
}
@x:  -t V {
	echo Executing @x
}
V {
	exit 1
}

#
# Canonicalize names 
#
# - Fold multiple / to a single one, except exactly two at the beginning
# - Remove ending /, except for single '/'
# - Fold ., except for a single .
# - Fold */.. (.. at beginning stays)
# 
# (Don't do anything special with symlinks/hardlinks/etc.; they need
# syscalls to detect anyway.)
#
# Questions
#   - Should '/' match in parameters?  -> Yes
#   - Does that also apply to transient targets?  -> Yes
#

#      - aaa/.. ->  .
#      - aaa/../bbb -> bbb
#      - .. -> ..
#      - ../aaa -> ../aaa
#      - /../aaa -> /aaa
#      - aaa/bbb/../../ccc -> ccc
#      - . -> .
#      - ./ -> .
#      - aaa/. -> aaa
#      - aaa/ -> aaa
#      - ./aaa -> aaa
#      - .//aaa -> aaa
#      - ./. -> .
#      - aaa//bbb -> aaa/bbb
#      - //aaa -> //aaa
#      - ///aaa -> /aaa
#      - ////aaa -> /aaa
#      - // -> /
#      - /// -> /
#      - ./ -> .
#      - /. -> /
#      - aaa -> aaa
#      - aaa/bbb -> aaa/bbb
#      - / -> / 

#
# When a parametrized name contains a slash in a nonparametrized part,
# any subsequent parameters cannot match a slash.  This is taken into
# account for computation of dominance. 
#

# Given
$name.bib;   # Rule (1)
./$name.bib; # Rule (2)
# The name dir/aaa.bib will match rule (1).
# The name aaa.bib will match both rules. 

# This is not nice because it starts doing the "allow regexp for
# parameter thing". 

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
 
# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

# - What about transient transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];

#
# Use the '+' sign to invert flags. 
#

# E.g.: Dynamic dependencies are "persistent" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
A.tar: [ +p FILES ] { tar cfvv A.tar $(cat FILES) }

#
# Logging:  an option to write log messages into a file.  In particular,
# which commands failed. (option -l)
#

#
# An option for automatic logging:  write all output (stdout/stderr) of
# commands to a file (a different file per target).  Use the -l option.
# To do this, we need to generate a logfile name for each file and
# transient target in a systematic manner.  This opens many questions. 
#

#
# Recursive persistent dependency:  If the file exists, never
# rebuild it, regardless whether its dependencies have to be rebuilt.
# Actual persistent dependencies do not work like this, as they only
# ignore the targets timestamp, but don't change anything about its
# dependencies.  
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc. 
% include c++.stu
 
#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed. 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '-o':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
-o $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# Have a flag to prevent echoing of the command. (Similar to '@' in
# Make)
#

#
# A "hard optional" option:  If a dependency is not present, don't even
# try to rebuild the target if it's already present.  I.e., an
# "up-percolating" 'optional' flag.
#

#
# -m bfs (breadth-first order) and -m target (pseudotarget by target
# name). 
#

#
# Have a mode or option to show only once message per error, omitting
# all subsequent traces.
#

#
# Correct parsing of shell syntax in commands:  { and } only have their
# meaning when they are not attached to other words, and when they are
# the first word in a command.
#
# However, do this everywhere except at the outer level.  At the outer
# level, every } preceded by whitespace ends the command. 
#

# Unexpected ';'
#     >A { echo } ; }

# OK -- this does not work at the moment 
#     >A { { echo } ; } ; echo aaa }

#
# Allow access to environment variables via e.g. $(HOME). 
#

#
# In parallel mode, don't show the full trace after and error, but only
# a one-liner. 
#

#
# More ways to specify how many/which commands to run, apart from -j.
# These can be based on:
#  - Memory consumption
#  - CPU usage / load average
#  - etc.
#
# It's hard to define which of such rules would be universal enough to
# be included in Stu. 
#

#
# Have proper Autoconf support for C++11, and not just using -std=c++11
# directly.  
#

#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

% file datasets.list
% line 120

# Use this in texdep and other stu-utils programs judiciously. 

#
# A 'why' option that shows why things are built.  Will look similar to
# error traces, only containing explanations. 
#

# * 'abc' does not exist
# * 'abc' is older than its dependency 'xyz'
# * ...

#
# An option to ignore all timestamps:  Whenever a file already exists,
# it is not rebuilt.  
#

#
# Have an option for: For hardcoded rules, compare the content of the
# file (if it exists) with the declared content, and regenerate the file
# if necessary.
#

#
# An option that make Stu rebuild everything, regardless of status. (-B,
# like GNU Make)   
#

#
# We may rewrite part of execution.hh to not use the flag bits, and
# instead use classes such as 
#
#	Optional_Execution, Trivial_Execution, Persistent_Execution,
# 	etc. 
#

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single like, e.g. separated by tab.  (Use it then to perform a network
# analysis of the KONECT-Analysis dependency graph.)
#

#
# For output redirection:  Do what stu-utils/output-finally does,
# integrated into Stu.  On the other hand, this is not totally good,
# because users expect a > operator to write into the file immediately.
# Maybe only enable it with a flag.  Alternatively, automatically make a
# backup of the target file, and restore it if the command fails.
# Again, this should only be done with a flag, because given the large
# possible files, it would take lots of memory.  A smart way to do it
# would be to open() the file, keeping only a reference in the Stu
# process to it, and then linking it again if needed, but that is
# probably not possible ini POSIX. 
#

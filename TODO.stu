#
# Concatenation [2.5]    test/2.5-*
#

A:  B[C];      	        # Juxtaposition
A:  [B]C;      	        # OK
A:  B[C]D;     	        # OK
A:  [B][C]; 	        # OK
A:  [B][C];             # OK
A:  ($[B])(C);    	# error
A:  (B)($[C]);    	# error
A:  <B[C];		# OK iff C contains exactly one dependency (otherwise an error)
@A: @B[C];       	# OK
A.$X.$Y:  ($X)($Y)      # OK (can be contiguous)
A.$X.$Y:  ($X.a)(b.$X)  # OK (despite duplicate parameter) 
A.$X.$Y:  ($X.)($Y)     # OK
A.$X.$Y:  ($X)(.$Y)     # OK

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

# Copy all *.dat files to the backup/ directory, but only if they don't
# exist yet, or if they have changed. 
@all: backup/[FILES];
>FILES: { echo *.dat ; }
backup/$file = $file;

A:   -p ( X )( Y );

# Other tests
A:  B() { cp B A }  B = {correct}
A:  ()B { cp B A }  B = {correct}
... ()(A)  # Empty or just 'A' (empty would be logical, because () is an
           # empty list
A:  list.[B];
A:  list.[[B]];
A:  [[B]][[B]]; 
A:  [[B][C]]; 
A:  [[(B)(C)]]; 
A:  ()();  # Empty or error?   Empty is logical; error may catch some Stu code bugs. 

# Test a case in which the concatenated files are not readable, i.e. because of chmod(2). 

A: [[X]](Y);  

A:  A[-o B];  # When B does not exist:  empty dependency list. 

A:  $[B(C D)];  # ??

A:  B.${X}(${Y});  # Error because of contiguous parameters 

# Two different meanings [assuming three strings in each of X/Y/Z):
A:  list.[X Y Z];   # Same as list.( [X] [Y] [Z] ):  9 variants
A:  list.[X][Y][Z]; # Multiple all together:  27 variants 

A:  [X][Y]; # OK
A:  [X]@Y;  # Error
A:  X[Y];   # OK
A:  [X]Y;   # OK
A:  (X)[Y]; # OK
A:  [X](Y); # OK

# The following two are not the same 
A:  [X][[Y][Z]];
A:  [[X][Y]][Z];

A:  [ (X) (Y) (Z) ]; 
A:  list.([X][Y]); 

A:  [B];   B = { ([X])(([Y]([Z]))) }   X = { list. }   Y = { 1 2 }   Z = Y;

A:  list.[X][X][X][X][X][X][X][X];   X = { 1 2 }   >list.$n { echo Number "$n" ; }

A: list.[X];   X = {[Y]}   Y = {Z};  # Equivalent to   A: list.Z;
A: [list.[X]]; X = {[Y]} Y = {Z} list.Z = {Q}  # Equivalent to    A: Q;

# All six list.* files are built. 
@all:  A B;
A:  list.a[[M]];
B:  list.b[[M]];
M = { N }
N = { 1 2 3 }
list.$x = { xxx }

# Order of parts
A:  [B][C] { ... }
>B { sleep 2 ; echo list. ; }
C = { 1 2 3 }
list.$n;

# Start building 'list.C' immediately, and 'list.D' later. 
A:  list.([B] C) { ... ; }
B = { sleep 1 ; echo D ; }
>list.$n { echo "$n" ; }

# Should this mean 'list.', or an empty list as dependencies of 'A'?  It
# should mean an empty list. 
A:   list.[B] { ... }
B = { }

# Should we allow this?  Yes.  Since 'C' is empty, this is an empty
# dependency. 
A: @[C]
{
	touch A
}
C { touch C ; }

# Strong cycle in the context of concatenation 
A:  list.[B];
B = {C}
list.C:  A; 

>A:  B -t list.[C] { cat B list.{1,2,3} ; }
B = {bbb}
C = {1 2 3}
>list.$n { echo "$n$n$n" ; }

A: @[X] { cp C A ; }
X = { y }
@y: C;
C = {correct}

# * Update the man page for concatenation 

# * error traces from concatenation 

#
# TODO document the -0 in the manpage.
#

#
# BSD/Macos compatibility:
# * Don`t use `;` in sed
# * Don`t use \s, \S and \t in sed
#

#
# Make sure that in -j2 -k mode, the "successfully built" message is
# output just once, when the rule that was run has multiple targets.
#

#
# In the following case, there should be an explanation message that two
# parameters cannot be continguous.
#

A.$X$Y;

#
# When an unknown flag is encountered, have an explanation of all valid
# flags.  
#

#
# When '*' is encountered in a file, show an explanation saying which
# characters are not allowed. 
#

#
# Semi-bug:  when a command read stdin but there is no input redirection, the
# current behaviour of Stu is to go into "fake interactive" because a
# fatal signal is sent.  Make it such that the job fails immediately. 
#

#
# At the moment, "stu -g" does not disable the flag -o in copy rules, i.e.
#
#   A = -o B;
#
# but it should.  
#

#
# sh/test:  log all tests and their runtime, version number, date, etc.
# This is to detected regression such as "a new version of Stu is much
# slower than old versions."
#

# 'A' will contain the three lines 'x', 'y' and 'z'
>A: [@x] { cat X Y Z ; }
@x:  X Y Z; 
X = {x}   Y = {y}  Z = {z}

#
# Check that random mode and -j2 work together when there is just a
# single thing to run in parallel.  Same for higher -jK when there are
# less than K things to run. 
#

#
# Write a test with really long filenames and really long chains of
# dependencies.  
#

#
# Test what happens when a file passed with -n contains a \0 character.
# It should be considered a syntax error and thus should should be a
# logical error (exit status 2). 
#

#
# Have a feature to indicate that a file contains only a single
# filename.  To complement -n and -0.  Must produce a logical error when
# the file contains the nul byte '\0'.  '\n' and other whitespaces
# should work.  
#

#
# Make sure we don't compile in any of the multi-threaded libraries.
# (For curiosity)   
#

# 
# Test that this fails as it should:
# 

@all:  @x.abc;
@x.$name A.$name: { exit 0 ; }

#
# Actually use the PACKAGE_URL field from autoconf. 
#

#
# Instead File_Execution::executions_by_pid, have a dedicated array for
# the list of currently running PIDs, and maintain an atomic pid_count
# to maintain the list, to avoid access a stdlib container from a signal
# handler.
#

#
# In File_Execution::wait(), use a non-blocking wait() function to
# handle all finished jobs in a loop in that function.
#

#
# Job::Signal::Signal: Execute the signal setup code only when needed,
# i.e., when something is started. 
#

#=================== Further features =======================

#
# Allow a better integrated syntax on the command line after '--'.  This
# will complement the options -o/-p/-n/-0.
#
# Write a tokenizer for it and use the usual parser.  The tokenizer
# should:
#    - recognize operators only at the beginning and end of arguments
#    - treat whitespace within arguments as part of the name, and only
#      consider the separation between arguments to be whitespace
#    - don't support '$'
#    - don't need space after flags 
#

$ stu -- [ -n FILES ]
$ stu -- -o FILE
$ stu -- -oFILE
$ stu -- [FILE]
$ stu -- [-oFILE]

#
# Canonicalize names 
#
# - Fold multiple / to a single one, except exactly two at the beginning
# - Remove ending /, except in single '/'
# - Fold ., except for a single .
# - Fold */.. (.. at beginning stays)
# 
# (Don't do anything special with symlinks/hardlinks/etc.; they need
# syscalls to detect anyway.)
#
# Questions
#   - Should '/' match in parameters?  -> Yes
#   - Does that also apply to transient targets?  -> Yes
#

#      - aaa/.. ->  .
#      - aaa/../bbb -> bbb
#      - .. -> ..
#      - ../aaa -> ../aaa
#      - /../aaa -> /aaa
#      - aaa/bbb/../../ccc -> ccc
#      - . -> .
#      - ./ -> .
#      - aaa/. -> aaa
#      - aaa/ -> aaa
#      - ./aaa -> aaa
#      - .//aaa -> aaa
#      - ./. -> .
#      - aaa//bbb -> aaa/bbb
#      - //aaa -> //aaa
#      - ///aaa -> /aaa
#      - ////aaa -> /aaa
#      - // -> /
#      - /// -> /
#      - ./ -> .
#      - /. -> /
#      - aaa -> aaa
#      - aaa/bbb -> aaa/bbb
#      - / -> / 

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
 
# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

# - What about transient transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];

#
# Use the '+' sign to invert flags. 
#

# E.g.: Dynamic dependencies are "persistent" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
A.tar: [ +p FILES ] { tar cfvv A.tar $(cat FILES) }

#
# Logging:  an option to write log messages into a file.  In particular,
# which commands failed. (option -l)
#

#
# Recursive persistent dependency:  If the file exists, never
# rebuild it, regardless whether its dependencies have to be rebuilt.
# Actual persistent dependencies do not work like this, as they only
# ignore the targets timestamp, but don't change anything about its
# dependencies.  
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc. 
% include c++.stu
 
#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed.  This will not catch certain errors
# anymore. 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '-o':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
-o $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# A "hard optional" option:  If a dependency is not present, don't even
# try to rebuild the target if it's already present.  I.e., an
# "up-percolating" 'optional' flag.
#

#
# -m bfs (breadth-first order) and -m target (pseudorandom by target
# name). 
#

#
# Have a mode or option to show only one message per error, omitting
# all subsequent traces.
#

#
# Correct parsing of shell syntax in commands:  { and } only have their
# meaning when they are not attached to other words, and when they are
# the first word in a command.
#
# However, do this everywhere except at the outer level.  At the outer
# level, every } preceded by whitespace ends the command. 
#

# Unexpected ';'
#     >A { echo } ; }

# OK -- this does not work at the moment 
#     >A { { echo } ; } ; echo aaa }

#
# Allow access to environment variables via e.g. $(HOME). 
#

#
# More ways to specify how many/which commands to run, apart from -j.
# These can be based on:
#  - Memory consumption
#  - CPU usage / load average
#  - etc.
#
# It's hard to define which of such rules would be universal enough to
# be included in Stu. 
#

#
# Have proper Autoconf support for C++11, and not just using -std=c++11
# directly.  
#

#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

% file datasets.list
% line 120

# Use this in texdep and other stu-utils programs judiciously. 

#
# A 'why' option that shows why things are built.  Will look similar to
# error traces, only containing explanations. 
#

# * 'abc' does not exist
# * 'abc' is older than its dependency 'xyz'
# * ...

#
# An option to ignore all timestamps:  Whenever a file already exists,
# it is not rebuilt.  
#

#
# Have an option for: For hardcoded rules, compare the content of the
# file (if it exists) with the declared content, and regenerate the file
# if necessary.
#

#
# An option that make Stu rebuild everything, regardless of status. (-B,
# like GNU Make)   
#

#
# We may rewrite part of execution.hh to not use the flag bits, and
# instead use classes such as 
#
#	Optional_Execution, Trivial_Execution, Persistent_Execution,
# 	etc. 
#

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single like, e.g. separated by tab.  (Use it then to perform a network
# analysis of the KONECT-Analysis dependency graph.)
#

#
# For output redirection:  Do what stu-utils/output-finally does,
# integrated into Stu.  On the other hand, this is not totally good,
# because users expect a > operator to write into the file immediately.
# Maybe only enable it with a flag.  Alternatively, automatically make a
# backup of the target file, and restore it if the command fails.
# Again, this should only be done with a flag, because given the large
# possible files, it would take lots of memory.  A smart way to do it
# would be to open() the file, keeping only a reference in the Stu
# process to it, and then linking it again if needed, but that is
# probably not possible ini POSIX. 
#

#
# Have an option defined on targets that will make a backup of the
# target file before running the command, and restore the target on
# error.  To be used with badly-behaving commands that overwrite the
# target immediately.
#

#
# In -k mode, Start trivial dependencies immediately when it iss clear
# they must be started, not just when everything else is done.
#

#==== Features of Stu 2:  Mandatory ====

#
# The file 'MATLABPATH' must inherit the '-t' flag. 
#

@matlab:  -t (matlab $[MATLABPATH]);

out: @matlab
{
	./matlab ... >out
}

#
# Option -Y to enable color output explicitly
#

#
# Flag -n for newline-separate filename lists
#

A: [ -n B ] { while read -r file ; do ... "$file" ... ; done }
>B { find ... }

#
# Have a way for dynamic dependencies to contain \0-separated filenames,
# to avoid quoting.  Not clear that this is the best syntax for it.
#

A: [ -0 <B ] { xargs -0 ... }

#
# Make 
#
#    A = -o B ;
#
# work:
#   * Fail when both A and B are not present
#   * Succeed when A is present and B is not
#   * Copy the file when B is present using the usual rules
#

#
# String multiplication.  String multiplication is to work both with the
# binary operator '*' as well with juxtaposition.  Juxtaposition is
# backward incompatible, as in Version 1 strings like "A[B]" where
# interpreted as two dependencies, and with it they will be interpreted
# as one. 
#

A:  B * C;    	        # Binary multiplication operator
A:  B * (C D); 	        # Parentheses
A:  B[C];      	        # Juxtaposition
A:  [B]C;      	        # OK
A:  B(C D);    	        # OK
A:  B(C D)E;   	        # OK
A:  B[C]D;     	        # OK
A:  [B] * [C]; 	        # OK
A:  (A B) * (C D); 	# OK
A:  [B][C];             # OK
A:  (A B)(C D);         # OK
A:  (-p B) * (C);    	# OK
A:  (-o B) * (C);    	# OK
A:  (B) * (-p C);    	# error
A:  (B) * (-o C);    	# error
A:  (-o B) * (-p C);   	# error
A:  (<B) * (C);    	# OK
A:  (B) * (<C);    	# error
A:  -p B(C D);       	# OK
A:  -o B(C D);       	# OK
A:  <B(C);         	# OK
A:  <B(C D);       	# error
A:  @B(C);         	# OK
A:  @B(C D);     	# OK
A:  B * @C;      	# error 
A:  $[B] * C;    	# error
A:  B * $[C];    	# error
A:  <B * C;      	# OK (or maybe:  ambiguous)
A:  B * <C;      	# error
A:  <B[C];		# OK iff C contains exactly one dependency (or an error)
@A: @B[C];       	# OK
A:  B@C;		# error
A.$X.$Y:  $X * $Y       # OK (can be contiguous)
A.$X.$Y:  $X.a * b.$X   # OK (despite duplicate parameter) 
A.$X.$Y:  $X. * $Y      # OK
A.$X.$Y:  $X * .$Y      # OK

# More examples

@headers:  (config parse build).h

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

# Copy all *.dat files to the backup/ directory, but only if they don't
# exist yet, or if they have changed. 
@all: backup/[FILES];
>FILES: { echo *.dat }
dest/$file = $file;

#
# Features with flags. 
#
# Have options to switch all of these in subsequent targets, or to
# switch it off. 
#
# Maybe, invert the meaning of '-' and '+' to have '+' mean "switch
# on". 
#
# Have corresponding command-line options. 
#

#
# What happens with relative and absolute pathnames?  When two names
# refer to the same file?  Do we need to 'normalize' (canonicalize) names?
#
# * fold ..
# * fold ., except for a single .
# * Remove ending / 
# * Fold multiple / to a single one, except exactly two at the beginning
# * don't touch symlinks/hardlinks/etc. (they need syscalls to detect anyway) 
#
# Question:  should '/' match in parameters?  -> Yes
#

# This will fail because ../../bib/$NAME.bib will match $NAME.bib.
# Instead, be able to write ./$NAME.bib
A:   a.bib b.bib c.bib;
$NAME.bib:  ../../bib/$NAME.bib { cp ... }
a.bib;

# Rules:
#     $NAME.bib:    a .bib file anywhere
#     ./$NAME.bib:  a .bib file in the current directory

# Remove trailing slash from directory names.
A:  -o tmp/ {...}
tmp: {...}

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of

# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

#==== Features of Stu 2:  Other features ====

#
# Recursive persistent dependency:  If the file exists, never
# rebuild it, regardless whether its dependencies have to be rebuilt.
# Actual persistent dependencies do not work like this, as they only
# ignore the targets timestamp, but don't change anything about its
# dependencies.  
#

#
# Have an option to suppress warnings.  (which?)
#

#
# New flag to ALWAYS build a target.  (We may already have this?)
#

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];
A: [data//B]; # ?

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

% include c++.stu
 
#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed. 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '-o':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
-o $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# Variables of the flags that apply to all children, not just immediate
# ones.  
#

$ stu '-E A'

# will completely ignore timestamps in all files.  

# This will also cover cases that are implemented as options at the
# moment, e.g. -g: 

$ stu '+o A'

# is equivalent to

$ stu -g A

# In this example, '\' is the negation operator. 

#
# Disable flags with '+' options
#

A: -o @x;
@x: +o B;

# Equivalent to
A: B;

#
# Dynamic dependencies are "persistent" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
#

A.tar: [ +e FILES ] { tar cfvv A.tar $(cat FILES) }

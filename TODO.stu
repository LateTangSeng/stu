#
# In the following case, there should be an explanation message that two
# parameters cannot be continguous.
#

A.$X$Y;

#
# When an unknown flag is encountered, have an explanation of all valid
# flags.  
#

#
# When '*' is encountered in a file, show an explanation saying which
# characters are not allowed. 
#

#
# Semi-bug:  when a command read stdin but there is no input redirection, the
# current behaviour of Stu is to go into "fake interactive" because a
# fatal signal is sent.  Make it such that the job fails immediately. 
#

# Example that triggers it:
$ stu -F 'A {cat $(cat ahjsahd);}'
# (where the file 'ahjsahd' is not present) 

#
# At the moment, "stu -g" does not disable the flag -o in copy rules, i.e.
#
#   A = -o B;
#
# but it should.  
#

#
# sh/test:  log all tests and their runtime, version number, date, etc.
# This is to detect regressions such as "a new version of Stu is much
# slower than old versions."
#

#
# This test
#

# 'A' will contain the three lines 'x', 'y' and 'z'
>A: [@x] { cat X Y Z ; }
@x:  X Y Z; 
X = {x}   Y = {y}  Z = {z}

#
# Check that random mode and -j2 work together when there is just a
# single thing to run in parallel.  Same for higher -jK when there are
# less than K things to run. 
#

#
# Write a test with really long filenames and really long chains of
# dependencies.  
#

#
# Test what happens when a file passed with -n contains a \0 character.
# It should be considered a syntax error and thus should should be a
# logical error (exit status 2). 
#

#
# Make sure we don't compile in any of the multi-threaded libraries.
# (For curiosity)   
#

# 
# Test that this fails as it should:
# 

@all:  @x.abc;
@x.$name A.$name: { exit 0 ; }

#
# Actually use the PACKAGE_URL field from autoconf. 
#

#
# Instead File_Execution::executions_by_pid, have a dedicated array for
# the list of currently running PIDs, and maintain an atomic pid_count
# to maintain the list, to avoid access a stdlib container from a signal
# handler.
#

#
# Can the options -k or -j be used in -q mode?  Yes; they should be a
# no-op then. 
#

#
# In -s -j mode, 'Successfully built' messages should not be output. 
#

#
# Test all 'switch' cases, like this:
#

A:  -X <CCC>  -Y <CCC>  { ... }

# where:
#   -X and -Y are all possible combinations of transitive flags
#   <CCC> is one of:
#      (1) Direct dependency C
#      (2) Transient to C
#      (3) Dynamic dependency that contains C
#      (4) Concatenation that results in C

#
# delete_tmps:  don't remove ?? and dep.*, as these patterns appear in
# stu/.  Change tests that use these patterns.  Remove the script to
# remove_*. 
#

#
# Traces:  show only the first line with the most information message in
# red, and other traces in another color. 
#

#
# Have proper Autoconf support for C++11, and not just using -std=c++11
# directly.  
#

#=================== Further features =======================

#
# In File_Execution::wait(), use a non-blocking wait() function to
# handle all finished jobs in a loop in that function.  
#

#
# Job::Signal::Signal: Execute the signal setup code only when needed,
# i.e., when something is started. 
#

#
# Allow a better integrated syntax on the command line after '--'.  This
# will complement the options -o/-p/-n/-0.
#
# Write a tokenizer for it and use the usual parser.  The tokenizer
# should:
#    - recognize operators only at the beginning and end of arguments
#    - treat whitespace within arguments as part of the name, and only
#      consider the separation between arguments to be whitespace
#    - don't support '$'
#    - don't need space after flags 
#    - recognize '[' and ']' in the middle of the string, to denote
#      concatenation 
#

$ stu -- [ -n FILES ]
$ stu -- -o FILE
$ stu -- -oFILE
$ stu -- [FILE]
$ stu -- [-oFILE]
$ stu -- list.[FILE]

#
# Canonicalize names 
#
# - Fold multiple / to a single one, except exactly two at the beginning
# - Remove ending /, except in single '/'
# - Fold ., except for a single .
# - Fold */.. (.. at beginning stays)
# 
# (Don't do anything special with symlinks/hardlinks/etc.; they need
# syscalls to detect anyway.)
#
# Questions
#   - Should '/' match in parameters?  -> Yes
#   - Does that also apply to transient targets?  -> Yes
#

#      - aaa/.. ->  .
#      - aaa/../bbb -> bbb
#      - .. -> ..
#      - ../aaa -> ../aaa
#      - /../aaa -> /aaa
#      - aaa/bbb/../../ccc -> ccc
#      - . -> .
#      - ./ -> .
#      - aaa/. -> aaa
#      - aaa/ -> aaa
#      - ./aaa -> aaa
#      - .//aaa -> aaa
#      - ./. -> .
#      - aaa//bbb -> aaa/bbb
#      - //aaa -> //aaa
#      - ///aaa -> /aaa
#      - ////aaa -> /aaa
#      - // -> /
#      - /// -> /
#      - ./ -> .
#      - /. -> /
#      - aaa -> aaa
#      - aaa/bbb -> aaa/bbb
#      - / -> / 

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
 
# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

# - What about transient transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];

#
# Use the '+' sign to invert flags. 
#

# E.g.: Dynamic dependencies are "persistent" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
A.tar: [ +p FILES ] { tar cfvv A.tar $(cat FILES) }

#
# Trace (logging): an option to write log messages into a file.  In
# particular, which commands failed. (option -T)
#

#
# Recursive persistent dependency:  If the file exists, never
# rebuild it, regardless whether its dependencies have to be rebuilt.
# Actual persistent dependencies do not work like this, as they only
# ignore the targets timestamp, but don't change anything about its
# dependencies.  
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc. 
% include c++.stu
 
#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed.  This will not catch certain errors
# anymore. 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '-o':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
-o $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# A "hard optional" option:  If a dependency is not present, don't even
# try to rebuild the target if it's already present.  I.e., an
# "up-percolating" 'optional' flag.
#

#
# -m bfs (breadth-first order) and -m target (pseudorandom by target
# name). 
#

#
# Have a mode or option to show only one message per error, omitting
# all subsequent traces.
#

#
# Correct parsing of shell syntax in commands:  { and } only have their
# meaning when they are not attached to other words, and when they are
# the first word in a command.
#
# However, do this everywhere except at the outer level.  At the outer
# level, every } preceded by whitespace ends the command. 
#

# Unexpected ';'
#     >A { echo } ; }

# OK -- this does not work at the moment 
#     >A { { echo } ; } ; echo aaa }

#
# Allow access to environment variables via e.g. $(HOME). 
#

#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

% file datasets.list
% line 120

# Use this in stu-utils/texdep and other stu-utils programs judiciously. 

#
# A 'why' option that shows why things are built.  Will look similar to
# error traces, only containing explanations. 
#

# * 'abc' does not exist
# * 'abc' is older than its dependency 'xyz'
# * ...

#
# An option to ignore all timestamps:  Whenever a file already exists,
# it is not rebuilt.  
#

#
# Have an option for: For hardcoded rules, compare the content of the
# file (if it exists) with the declared content, and regenerate the file
# if necessary.
#

#
# An option that make Stu rebuild everything, regardless of status. (-B,
# like GNU Make)   
#

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single like, e.g. separated by tab.  (Use it then to perform a network
# analysis of the KONECT-Analysis dependency graph.)
#

#
# For output redirection:  Do what stu-utils/output-finally does,
# integrated into Stu.  On the other hand, this is not totally good,
# because users expect a > operator to write into the file immediately.
# Maybe only enable it with a flag.  Alternatively, automatically make a
# backup of the target file, and restore it if the command fails.
# Again, this should only be done with a flag, because given the large
# possible files, it would take lots of memory.  A smart way to do it
# would be to open() the file, keeping only a reference in the Stu
# process to it, and then linking it again if needed, but that is
# probably not possible in POSIX. 
#

#
# In -j>1 mode, Start trivial dependencies immediately when it is clear
# they must be started, not just when everything else is done.
#

#
# A flag with the meaning "never rebuild that dependency", but only use
# it to determine whether we need to rebuilt the target.  It would mean
# that we can prune dependencies with that flag as soon as we know that
# the target must be built anyway.  
#

# In this example, when 'program' does not exist, Stu will *not* build
# 'dep.sources', because the -s flag is used and Stu knows that
# 'program' has to be rebuilt anyway.  '-s' could stand for
# "secondary", and mean "we don't want this to be built, we only need it
# to determine whether we have to be rebuilt."

program:  -s [dep.sources] {
	cc ... -o program
}
dep.sources {
	# Some complex mechanism for determining the source code files
	# of the program
}

#
# Allow concatenation of file dependencies with input redirection.  This
# is not valid at the moment.  Should be only valid if a single
# dependency results.  The current behavior is consistent with input
# redirection being invalid within dynamic dependencies. 
#

A:  <list.(B) { ... }

#
# Allow empty names in concatenation.
#

A:  list.( '' ); # Equivalent to just 'list.'

A:  @[X]; 

#
# The Dep::top mechanism is not clean.  Do something better.  
#

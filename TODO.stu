#
# Nice errors
#

# * Get rid of print_*() and always show a place (maybe)
# * Place-less errors: write $0 in bold

# command-outside-of-rule
# content-2
# content-20
# content-3
# content-5
# contiguous-parameters
# copy-14
# copy-15
# color-2:  show the invalid argument
# copy-16:  mention '=' and the rule name
# copy-17:  mention target name
# copy-3
# copy-4
# copy-41
# copy-5
# copy-6
# copy-7
# copy-8
# default-dynamic
# dynamic-target
# dynamic-variable-equal-parameter:  mention the given value
# empty-filename-1:  name >>of dependency<< of target A must not be empty
# empty-parameter
# empty-parameter2
# error-b:  for which target?
# expected-a-dependency:  for which target?
# first-rule-parametrized:  mention the target
# in-target:  parameter $XXX must not appear in dependency YYY // because it does not appear in target ZZZ
# include-dynamic: use "must not appear"
# include-end:  expected statement name after %
# include-error
# include-in-dynamic-dependency:  split the two cases
# include-nofile:  more context
# include-nofile2
# include-nofilename: use "expected filename"
# include-parametrized:  mention the filename and parameter
# include-recursion-indirect2:  show the two filenames per line 
# input-multiple:  mention target name
# input-nocommand: mention target
# invalid-equal
# isdir: what was the file/dir used for?
# jobs:  mention argument
# jobs2: mention argument
# jobs3: mention argument
# jobs4: mention argument
# killed: also mention signal number:  ... received signal 9 (Killed)
# lone-colon, lone-equal, lone-langle, lone-rbracket: mention what was found
# lone-rbracket2: say what was expected
# missing-rangle:  rephrase as "after opening ["
# multifile-3:  for what was the file used?
# multifile-{6,8}:  mention target
# multiple-parametrized-rules-with-same-number-of-parameters:  have a good explanation text
# multitarget-3: show what was found
# multitarget-33:  show targets
# multitarget-36:  show targets
# multitarget-4:  mention what was found instead
# multitarget-77:  show targets
# multitarget-83:  show targets
# multitarget-85:  mention both targets
# multitarget-86:  mention the transient target
# multitarget-{87,88,89}:  mention targets
# no-equal-in-dynamic-variable: mention the given variable name
# no-filename-after-dollar-langle:  mention what was found
# nocommandaftertarget: mention what was found
# nosuchfile, openat2, openat3:  mention for what the file as read 
# option-c-14:  separate the two cases
# option-f-nosuchfile: for what was the file needed?
# option-rule-12: mention what was found
# output-nocommand:  mention target
# param-{000,001,002}: mention what actually follows
# param-006: mention the name
# param-008: mention the name
# redirect-lone-output: what was found?
# redirect-missing-filename: what was found?
# redirect-output-transient:  mention the transient target
# redirect-transient: mention what was found
# space-parameter:  mention what was found
# statement-missing: mention what was found
# statement-newline:  mention what was found
# statement-short:  phrase as "expected XXX, found YYY"
# syntax-error-in-dynamic: mention what was found
# transient-input: mention what was found
# unexpected-end-rule:  mention what was found
# unexpected-rbracket:  mention what was found
# unfinished-double-quote, unfinished-single-quote:  mention what type of opening quote is used
# unmatched-lbrace, unmatched-twoparens: mention that commands start with '"'
# variable-name-1, variable-name-2: mention the variable name
# varpar-4: what was found?
# varpar-5:  mention the full name
# version-{invalid,long,partial}:  expected ...; found ...
# wrong-quote:  show both quotes
#  EVERYTHING after that

#
# Get rid of configure.ac.in.  Infer the version number
# programmatically.  See GNU programs for examples. 
#

#
# Get rid of errors on FreeBSD
#  * -s
#  * missing library functions 
#

#
# Make use of autoconf to detect CLOCK_REALTIME_COARSE and enable
# precise timestamps  
#

#
# Make sure that setting $CXX and $CXXFLAGS externally works. 
#

#==== Backward-incompatible features (in the switch to version 2) ====

#
# Make 'single quotes' and "double quotes" behave like in the shell,
# i.e., with respect to what needs to be quoted inside them. 
#

'abc"def'; # check with /bin/sh
"network $name"; 
"aaa'bbb"; # check with /bin/sh

#
# Use backslash for quoting?
#

#
# Don't allow filenames that start with '+' or '-', but allow these in
# the middle or at the end of filenames.  
#
# Maybe also those beginning with '~'. 
#

#
# Keep track of spacing between tokens, and disallow no space in
# situations that will later be used for string concatenation. 
#

#
# Use '-' options for the three flags !, ?, and &.   
#

A:  
	-e X # existence-only
	-o X # optional
        -t X # trivial
{ ... }

# Have options to switch all of these in subsequent targets, or to
# switch it off. 

# Maybe, invert the meaning of '-' and '+' to have '+' mean "switch
# on". 

#
# Deprecate !, ?, and &, and define as reserved for future extension. 
#

#==== Features of Stu 2:  Mandatory ====

#
# Flag -n for newline-separate filename lists
#

A: [ -n B ] { while read -r file ; do ... "$file" ... ; done }
>B { find ... }

#
# Have a way for dynamic dependencies to contain \0-separated filenames,
# to avoid quoting.  Not clear that this is the best syntax for it.
#

A: [ -0 <B ] { xargs -0 ... }

#
# String multiplication.  String multiplication is to work both with the
# binary operator '*' as well with juxtaposition.  Juxtaposition is
# backward incompatible, as in Version 1 strings like "A[B]" where
# interpreted as two dependencies, and with it they will be interpreted
# as one. 
#

A:  B * C;    	        # Binary multiplication operator
A:  B * (C D); 	        # Parentheses
A:  B[C];      	        # Juxtaposition
A:  [B]C;      	        # OK
A:  B(C D);    	        # OK
A:  B(C D)E;   	        # OK
A:  B[C]D;     	        # OK
A:  [B] * [C]; 	        # OK
A:  (A B) * (C D); 	# OK
A:  [B][C];             # OK
A:  (A B)(C D);         # OK
A:  (!B) * (C);    	# OK
A:  (?B) * (C);    	# OK
A:  (B) * (!C);    	# error
A:  (B) * (?C);    	# error
A:  (?B) * (!C);   	# error
A:  (<B) * (C);    	# OK
A:  (B) * (<C);    	# error
A:  !B(C D);       	# OK
A:  ?B(C D);       	# OK
A:  <B(C);         	# OK
A:  <B(C D);       	# error
A:  @B(C);         	# OK
A:  @B(C D);     	# OK
A:  B * @C;      	# error 
A:  $[B] * C;    	# error
A:  B * $[C];    	# error
A:  <B * C;      	# OK (or maybe:  ambiguous)
A:  B * <C;      	# error
A:  <B[C];		# OK iff C contains exactly one dependency (or an error)
@A: @B[C];       	# OK
A:  B@C;		# error
A.$X.$Y:  $X * $Y       # OK (can be contiguous)
A.$X.$Y:  $X.a * b.$X   # OK (despite duplicate parameter) 
A.$X.$Y:  $X. * $Y      # OK
A.$X.$Y:  $X * .$Y      # OK

# More examples

@headers:  (config parse build).h

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

#==== Features of Stu 2:  Other features ====

#
# What happens with relative and absolute pathnames?  When two names
# refer to the same file?  Do we need to 'normalize' names?
#
# * fold ..
# * fold ., except for a single .
# * Remove ending / 
# * Fold multiple / to a single one, except exactly two at the beginning
# * don't touch symlinks/hardlinks/etc. (they need syscalls to detect anyway) 
#
# Question:  should '/' match in parameters?
#

# This will fail because ../../bib/[NAME].bib will match [NAME].bib.
# Instead, be able to write ./[NAME].bib
A:   a.bib b.bib c.bib;
$NAME.bib:  ../../bib/$NAME.bib { cp ... }
a.bib;

# Rules:
#     [NAME].bib:    a .bib file anywhere
#     ./[NAME].bib:  a .bib file in the current directory

# Remove trailing slash from directory names.
A:  ?tmp/ {...}
tmp: {...}

#
# Advanced file inclusion 
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of

# Using an option
% include -d src/main.stu

# 'include' and 'import' would actually be inverted. 
% import src/main.stu
% import src/

#
# New flag to ALWAYS build a target.  (We may already have this)
#

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];
A: [data/B],d; 
A: [data//B]; # ?

#
# Option -N:  dry run, but build dynamic dependencies 
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

% include c++.stu
 
#
# Option -B:  Remake all targets regardless of dates
#

#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed. 
#

#
# Line number syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

%line ...

#
# An option for automatic logging:  write all output (stdout/stderr) of
# commands to a file (a different file per target).  Use the -l option. 
#

#
# -m bfs (breadth-first order) and -m target (pseudotarget by target
# name) 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '?':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
? $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# Variables of the flags that apply to all children, not just immediate
# ones.  
#

$ stu '!!A'

# will completely ignore timestamps in all files.  

# This will also make
# cover cases that are implemented as options at the moment, e.g. -g:

$ stu '\?A'

# is equivalent to

$ stu -g A

# In this example, '\' is the negation operator. 

#
# Disable flags with '+' options
#

A: -o @x;
@x: +o B;

# Equivalent to
A: B;

#
# Dynamic dependencies are "existence-only" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
#

A.tar: [ +e FILES ] { tar cfvv A.tar $(cat FILES) }

# 
# An option (-u) to consider all targets up to date.  I.e., execute only the
# minimum to get the given files built. 
#

#
# When accessing directories, maybe use not mtime, but something else?
#
# * when stat() succeeds and the file is a directory, use creation time
#   instead of modification time
# * this will make it impossible to build directories that are more than
#   just { mkdir -p }
#

#
# Removeable files:  when a file carries the removeable flag, it does
# not need to be present.  
#

A: -R B;  B: C;  A: D;

# * When A is old, B does not exist, and C is new:  rebuild B and A.
# * When A is new, B does not exist, and C is old:  don't rebuild A.
# * When A is new, B does not exist, C is old, and D is very new:  rebuild
#   B and A. 

# (There are no known bugs)

#=================== New features =======================

#
# Canonicalize names [2.6]
#

# Todo:
#       -- In Rule_Set::add(), when adding parametrized rules, canonicalize all
#          targets, and the matching must take that into account 
#       -- The check for multiple identical targets (in the parametrized
#          case) must use canonicalization 

# Error:  (not a) Duplicate target
A:  list.B { touch A; }
list.B xxx/../list.B { touch list.B; }

# Error:  Duplicate target
A:  list.B { touch A; }
list.B ./list.B { touch list.B; }

# The special ./${} exception
A: ./list.B { ... }
$path.B      { ... }
./$file      { ... }

# Parametrized case: .${x}st.a does not match  ./list.a 
A: ./list.a { cp list.a A ; }
.${x}st.a { exit 1 ; }
>list.a { echo CORRECT ; }

# Error:  list.$path is not allowed as $path starts with a slash (?)
A:  /bin/sh { touch A; }
$path/sh:  list.$path { touch -- "$path"/sh; }

# Matches
A: list.a { cp list.a A ; }
./list.$x { echo "$x" >./list."$x" ; }

# .//X is the same as ./X
A:  .//list.B { cp list.B A; }
$path/list.B { exit 1; }
./list.$name = {CORRECT}

# .//X is the same as ./X
A:  ./list.B { cp list.B A; }
$path/list.B { exit 1; }
.//list.$name = {CORRECT}

# Does not match
A:  // { touch A ; }
/$x    { exit 1  ; }
//     { exit 0  ; }

# Canonicalization in each of 'c' 'n' '0' 'o' 'p' '-C' '-J' on the command line

# The parametrized rule is not called
A:  X///Y { cp X/Y A ; }
X/Y { mkdir X ; echo CORRECT >X/Y ; }
X/${i}/Y { exit 1 ; }

# With parameters
A:  list.B { cp list.B A; }
./list.$name = {CORRECT}

# Other tests with parameters.  Use each pattern as the target of a
# rule, with the given dependency
#   $x//$y		B/C
#   $x///$y     	B/C
#   ///$x		/usr
#   //$x		//usr
#   $x/			B
#   ./$x		B
#   $x/.		B
#   $x/./$y     	B/C
#   $x/././$y   	B/C
#   $x/../$y    	C
#   $x/$y/../../$z    	D

# Other patterns with parameters:
#   xxx/.$x
#   $x./xxx
#   $x./
#   /.$x

# (?) Should "$dir/name" match "/name", with $dir set to "/"?

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
 
# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

# - What about transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc. 
% include c++.stu
 
#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies. 
#

% file datasets.list
% line 120

# Use this in stu-utils/texdep and other stu-utils programs judiciously. 

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single line, e.g. separated by tab.  (Use it then to perform a network
# analysis of the KONECT-Analysis dependency graph.)
#

#
# In -j>1 mode, Start trivial dependencies immediately when it is clear
# they must be started, not just when everything else is done.
#

#==== Features of Stu 2:  Mandatory ====

#
# In parallel mode, one-liner should include the PID (only with the -v
# option)
#

#
# For content commands, show the content when short and ASCII-ish
#

#
# In parallel mode, show extra "done successfully" messages for each
# command, in green.
#

#
# When removing files automatically at the end, display the number of
# files removed.
#

#
# verbose mode -v:
#  - Show PIDs when commands are started, and always show
#    end-of-commands outputs.
#  - With the -v option, show the list of all files removed, regardless
#    of the number.  
#

#
# Concatenation.  Concatenation is to work both with the
# binary operator '*' as well with juxtaposition.     [2.5]
#

# - implement compound dependencies
# - implement compound execution objects, which are deleted when they are done
#   (they don't have a Target object)

A:  B * C;    	        # Binary multiplication operator
A:  B * (C D); 	        # Parentheses
A:  B[C];      	        # Juxtaposition
A:  [B]C;      	        # OK
A:  B(C D);    	        # OK
A:  B(C D)E;   	        # OK
A:  B[C]D;     	        # OK
A:  [B] * [C]; 	        # OK
A:  (A B) * (C D); 	# OK
A:  [B][C];             # OK
A:  (A B)(C D);         # OK
A:  (-p B) * (C);    	# OK
A:  (-o B) * (C);    	# OK
A:  (B) * (-p C);    	# error
A:  (B) * (-o C);    	# error
A:  (-o B) * (-p C);   	# error
A:  (<B) * (C);    	# OK
A:  (B) * (<C);    	# error
A:  -p B(C D);       	# OK
A:  -o B(C D);       	# OK
A:  <B(C);         	# OK
A:  <B(C D);       	# error
A:  @B(C);         	# OK
A:  @B(C D);     	# OK
A:  B * @C;      	# error 
A:  $[B] * C;    	# error
A:  B * $[C];    	# error
A:  <B * C;      	# OK (or maybe:  ambiguous)
A:  B * <C;      	# error
A:  <B[C];		# OK iff C contains exactly one dependency (or an error)
@A: @B[C];       	# OK
A:  B@C;		# error
A.$X.$Y:  $X * $Y       # OK (can be contiguous)
A.$X.$Y:  $X.a * b.$X   # OK (despite duplicate parameter) 
A.$X.$Y:  $X. * $Y      # OK
A.$X.$Y:  $X * .$Y      # OK

# More examples

@headers:  (config parse build).h

@plot.all:   @plot.[NETWORKS];

@plot:    plot/[NETWORKS].eps;

# Copy all *.dat files to the backup/ directory, but only if they don't
# exist yet, or if they have changed. 
@all: backup/[FILES];
>FILES: { echo *.dat }
dest/$file = $file;

#
# Allow a better integrated syntax on the command line after '--'.  This
# will complement the options -o/-p/-n/-0.
#
# Write a tokenizer for it and use the usual parser.  The tokenizer
# should:
#    - recognize operators only at the beginning and end of arguments
#    - treat whitespace within arguments as part of the name, and only
#      consider the separation between arguments to be whitespace
#    - don't support '$'
#    - don't need space after flags 
#

$ stu -- [ -n FILES ]
$ stu -- -o FILE
$ stu -- -oFILE
$ stu -- [FILE]
$ stu -- [-oFILE]

#
# The 'trivial' flag '-t' should "go up" when applied to the
# dependencies of transient targets. 
#

# 'V' is built because 'A' does not exist. 
A: @x {
	[ -r V ] || {
		exit 1
	}

	cat V >A
}
@x:  -t V; 
V = {correct}

# 'V' is built 'A' does not exist.  The '-t' has to "go up". 
A: @x {
	[ "x$V" = xcorrect ] || {
		exit 1
	}

	echo "$V" >A
}
@x:  $[-t V];
V = {correct}

# The '-t' has to "go up".  Use this in KONECT. 
@all:   list.out;
>list.$name:
	@octave
{
	./list.octave Hello 
}
@octave:  -t ( list.octave $[P] );
list.octave 
{
	cat >list.octave <<EOF
#! /bin/sh
[ "x$P" = x... ] || {
	exit 1
}
echo "$@"
echo correct >A
EOF
	chmod u+x list.octave
}
P = {...}

# Even when a transient target has a command, the '-t' "goes up". 
A: @x {
	[ -r V ] && {
		exit 1
	}

	echo correct >A
}
@x:  -t V {
	echo Executing @x
}
V {
	exit 1
}

#
# Use the '+' sign to invert flags. 
#

# E.g.: Dynamic dependencies are "persistent" by default.  Make it
# possible to switch this off using '+e'.  This is useful when the
# dynamic dependency file itself is used by the target, e.g. when
# creating a tarball. 
A.tar: [ +p FILES ] { tar cfvv A.tar $(cat FILES) }

#
# Canonicalize names 
#
# - Fold multiple / to a single one, except exactly two at the beginning
# - Remove ending /, except for single '/'
# - Fold ., except for a single .
# - Fold */.. (.. at beginning stays)
# 
# (Don't do anything special with symlinks/hardlinks/etc.; they need
# syscalls to detect anyway.)
#
# Questions
#   - Should '/' match in parameters?  -> Yes
#   - Does that also apply to transient targets? 
#

#      - aaa/.. ->  .
#      - aaa/../bbb -> bbb
#      - .. -> ..
#      - ../aaa -> ../aaa
#      - /../aaa -> /aaa
#      - aaa/bbb/../../ccc -> ccc
#      - . -> .
#      - ./ -> .
#      - aaa/. -> aaa
#      - aaa/ -> aaa
#      - ./aaa -> aaa
#      - .//aaa -> aaa
#      - ./. -> .
#      - aaa//bbb -> aaa/bbb
#      - //aaa -> //aaa
#      - ///aaa -> /aaa
#      - ////aaa -> /aaa
#      - // -> /
#      - /// -> /
#      - ./ -> .
#      - /. -> /
#      - aaa -> aaa
#      - aaa/bbb -> aaa/bbb
#      - / -> / 

#
# When a parametrized name contains a slash in a nonparametrized part,
# any subsequent parameters cannot match a slash.  This is taken into
# account for computation of dominance. 
#

# Given
$name.bib;   # Rule (1)
./$name.bib; # Rule (2)
# The name dir/aaa.bib will match rule (1).
# The name aaa.bib will match both rules. 

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of

# All these are equivalent 
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src

# - What about transient transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import. 
#

A: [-d data/B];

#
# An option for automatic logging:  write all output (stdout/stderr) of
# commands to a file (a different file per target).  Use the -l option. 
#

#==== Features of Stu 2:  Other features ====

#
# Recursive persistent dependency:  If the file exists, never
# rebuild it, regardless whether its dependencies have to be rebuilt.
# Actual persistent dependencies do not work like this, as they only
# ignore the targets timestamp, but don't change anything about its
# dependencies.  
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

% include c++.stu
 
#
# Optimization:  when parsing rules, only save the "body" part of the
# rule (everything except the target) as an unparsed string.  Parse it
# properly only when needed. 
#

#
# Flag rules
#

# Allow flags on the target filenames.  Example with '-o':

# If $NAME.svg is present, use it to build $NAME.pdf.  If $NAME.svg is
# not present, allow $NAME.pdf to be present without any dependencies.
# The big question is how can the rule distinguish when the rule is
# activated.  When all dependencies exist?  When all dependencies
# *could* be built? 
-o $NAME.pdf:  $NAME.svg
{
	inkscape ...
}

#
# Uppercase flag is recursive:
#

# Ignores timestamps recursively
A: -P B;

#
# Have a flag to present echoing of the command. (Similar to '@' in
# Make)
#

#
# A "hard optional" option:  If a dependency is not present, don't even
# try to rebuild the target if it's already present. 
#

#
# -m bfs (breadth-first order) and -m target (pseudotarget by target
# name) 
#

#
# Have a mode to show only the first error message, not all subsequent
# traces. 
#

#
# Correct parsing of shell syntax in commands:  { and } only have their
# meaning when they are not attached to other words, and when they are
# the first word in a command.
#

# Write '}' to the file 'A'
>A { echo } ; }

# It will mean that ';' will be mandatory before a closing '}' that is
# not preceded by whitespace, just like it is in the shell. 

#
# Allow access to environment variables via e.g. $(HOME). 
#

#
# In parallel mode, don't show the full trace after and error, but only
# a one-liner. 
#

#
# More ways to specify how many/which commands to run, apart from -j.
# These can be based on:
#  - Memory consumption
#  - CPU usage / load average
#  - etc.
#
# It's hard to define which of such rules would be universal enough to
# be included in Stu. 
#
